# .gitignore

```
.wwebjs_auth
.wwebjs_auth/*
.wwebjs_cache
.wwebjs_cache/*
*.sqlite

# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
.pnpm-debug.log*

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage
*.lcov

# nyc test coverage
.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
jspm_packages/

# Snowpack dependency directory (https://snowpack.dev/)
web_modules/

# TypeScript cache
*.tsbuildinfo

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional stylelint cache
.stylelintcache

# Microbundle cache
.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# parcel-bundler cache (https://parceljs.org/)
.cache
.parcel-cache

# Next.js build output
.next
out

# Nuxt.js build / generate output
.nuxt
dist

# Gatsby files
.cache/
# Comment in the public line in if your project uses Gatsby and not Next.js
# https://nextjs.org/blog/next-9-1#public-directory-support
# public

# vuepress build output
.vuepress/dist

# vuepress v2.x temp and cache directory
.temp
.cache

# vitepress build output
**/.vitepress/dist

# vitepress cache directory
**/.vitepress/cache

# Docusaurus cache and generated files
.docusaurus

# Serverless directories
.serverless/

# FuseBox cache
.fusebox/

# DynamoDB Local files
.dynamodb/

# TernJS port file
.tern-port

# Stores VSCode versions used for testing VSCode extensions
.vscode-test

# yarn v2
.yarn/cache
.yarn/unplugged
.yarn/build-state.yml
.yarn/install-state.gz
.pnp.*
```

# .windsurfrules

```
# Development Rules

Always start coding sessions with **بسم الله الرحمن الرحیم**.

## Code Modification Rules

1. **No Unsolicited Refactoring**
   - Do not modify or refactor working code unless explicitly requested
   - Keep existing code structure intact if it's functioning correctly
   - Focus only on fixing actual bugs and issues

2. **Feature Changes**
   - Only implement new features when specifically asked
   - Do not add "nice to have" enhancements without explicit request
   - Keep changes minimal and focused on the requested task

3. **Code Style**
   - Maintain the existing code style
   - Do not change formatting or structure for aesthetic reasons
   - Follow the project's established patterns

4. **Dependencies**
   - Do not update or add new dependencies without explicit approval
   - Keep using existing libraries and versions that work

5. **Documentation**
   - Only update documentation for new changes
   - Do not modify existing documentation unless specifically asked

## When Making Changes

1. **Scope**
   - Stay strictly within the scope of the requested change
   - If additional changes might be beneficial, suggest them but don't implement without approval

2. **Testing**
   - Test only the modified components
   - Do not add new tests for existing functionality unless requested

3. **Error Handling**
   - Maintain existing error handling patterns
   - Do not enhance error handling without explicit request

Remember: The goal is to maintain stability. If it works, don't touch it!

```

# API.md

```md
# WhatsApp Ads Software API Documentation

## Base URL
All API endpoints are prefixed with `/api`

## Authentication
Authentication details will be handled through request headers. Specific implementation details to be added.

## WebSocket Events
The application uses WebSocket for real-time updates with the following event types:
- `whatsapp_status`: Updates about WhatsApp connection status
- `ad_job_update`: Updates about running ad campaigns
- `moderation_update`: Updates about content moderation activities

## Endpoints

### WhatsApp Management

#### GET /api/whatsapp/contacts
Get a paginated list of WhatsApp contacts.

**Query Parameters:**
- `page` (optional): Page number (default: 1)
- `pageSize` (optional): Items per page (default: 20)
- `search` (optional): Search contacts by name or number
- `isMyContact` (optional): Filter by saved contacts (true/false)

**Response:**
\`\`\`json
{
  "items": [
    {
      "id": "string",
      "name": "string",
      "phoneNumber": "string",
      "isMyContact": boolean,
      "profilePicUrl": "string (optional)",
      "lastSeen": "date (optional)",
      "status": "string (optional)"
    }
  ],
  "total": number,
  "page": number,
  "pageSize": number
}
\`\`\`

### Ad Campaign Management

#### POST /api/ads/jobs
Create a new ad campaign job.

**Request Body:**
\`\`\`json
{
  "templateId": "string",
  "targets": {
    "contacts": ["string"],
    "groups": ["string"],
    "numbers": ["string"]
  },
  "schedule": {
    "startAt": "datetime",
    "endAt": "datetime (optional)"
  }
}
\`\`\`

#### GET /api/ads/jobs
Get a list of ad campaign jobs.

**Query Parameters:**
- `page` (optional): Page number (default: 1)
- `pageSize` (optional): Items per page (default: 20)
- `status` (optional): Filter by job status

**Response:**
\`\`\`json
{
  "items": [
    {
      "id": "string",
      "status": "pending | running | completed | failed",
      "progress": number,
      "createdAt": "datetime",
      "startedAt": "datetime",
      "completedAt": "datetime",
      "stats": {
        "sent": number,
        "failed": number,
        "pending": number
      }
    }
  ],
  "total": number,
  "page": number,
  "pageSize": number
}
\`\`\`

### Message Templates

#### GET /api/templates
Get message templates.

**Query Parameters:**
- `page` (optional): Page number (default: 1)
- `pageSize` (optional): Items per page (default: 20)

**Response:**
\`\`\`json
{
  "items": [
    {
      "id": "string",
      "name": "string",
      "content": "string",
      "variables": ["string"],
      "createdAt": "datetime",
      "updatedAt": "datetime"
    }
  ],
  "total": number,
  "page": number,
  "pageSize": number
}
\`\`\`

### Moderation

#### GET /api/moderation/logs
Get moderation activity logs.

**Query Parameters:**
- `page` (optional): Page number (default: 1)
- `pageSize` (optional): Items per page (default: 20)
- `action` (optional): Filter by moderation action

**Response:**
\`\`\`json
{
  "items": [
    {
      "id": "string",
      "action": "approve | reject | flag",
      "reason": "string",
      "timestamp": "datetime",
      "moderator": {
        "id": "string",
        "name": "string"
      }
    }
  ],
  "total": number,
  "page": number,
  "pageSize": number
}
\`\`\`

### Contact Groups

#### GET /api/groups
Get contact groups.

**Query Parameters:**
- `page` (optional): Page number (default: 1)
- `pageSize` (optional): Items per page (default: 20)

**Response:**
\`\`\`json
{
  "items": [
    {
      "id": "string",
      "name": "string",
      "description": "string",
      "memberCount": number,
      "createdAt": "datetime",
      "updatedAt": "datetime"
    }
  ],
  "total": number,
  "page": number,
  "pageSize": number
}
\`\`\`

## Rate Limiting
The API implements rate limiting on message sending operations. Specific limits will be included in API responses through headers.

## Error Responses
All error responses follow this format:
\`\`\`json
{
  "error": {
    "code": "string",
    "message": "string",
    "details": {} // Optional additional error context
  }
}
\`\`\`

Common HTTP status codes:
- 200: Success
- 400: Bad Request
- 401: Unauthorized
- 403: Forbidden
- 404: Not Found
- 429: Too Many Requests
- 500: Internal Server Error

```

# backend/data/whatsapp-ads.sqlite.backup

This is a binary file of the type: Binary

# backend/package.json

```json
{
  "name": "whatsapp-ads-backend",
  "version": "1.0.0",
  "description": "WhatsApp Ads Software Backend",
  "main": "src/index.ts",
  "scripts": {
    "dev": "ts-node-dev --respawn --transpile-only src/index.ts",
    "build": "tsc",
    "start": "node dist/index.js",
    "typecheck": "tsc --noEmit",
    "migrate": "ts-node src/scripts/run-migrations.ts"
  },
  "dependencies": {
    "dotenv": "^16.4.7",
    "express": "^4.21.2",
    "express-zod-api": "^21.11.1",
    "qrcode-terminal": "^0.12.0",
    "sqlite3": "^5.1.7",
    "typeorm": "^0.3.21",
    "whatsapp-web.js": "^1.26.0",
    "ws": "^8.18.1",
    "zod": "^3.22.4"
  },
  "devDependencies": {
    "@types/express": "^4.17.21",
    "@types/node": "^20.17.24",
    "@types/qrcode-terminal": "^0.12.2",
    "@types/ws": "^8.18.0",
    "ts-node-dev": "^2.0.0",
    "typescript": "^5.8.2"
  }
}

```

# backend/src/config/database.ts

```ts
import { DataSource } from "typeorm";
import path from "path";
import { User } from "../entities/User";
import { ContactGroup } from "../entities/ContactGroup";
import { PhoneBook } from "../entities/PhoneBook";
import { MessageTemplate } from "../entities/MessageTemplate";
import { AdJob } from "../entities/AdJob";
import { ModerationLog } from "../entities/ModerationLog";

export const AppDataSource = new DataSource({
  type: "sqlite",
  database: path.join(__dirname, "../../data/whatsapp-ads.sqlite"),
  entities: [User, ContactGroup, PhoneBook, MessageTemplate, AdJob, ModerationLog],
  synchronize: true, // Set to false in production
  logging: process.env.NODE_ENV === "development",
});

```

# backend/src/controllers/ContactController.ts

```ts
import { z } from 'zod';
import { createApi, endpoint } from 'express-zod-api';
import { WhatsAppService } from '../services/WhatsAppService';

const contactFilterSchema = z.object({
  search: z.string().optional(),
  isMyContact: z.string().optional().transform(val => val === 'true'),
  page: z.string().optional().transform(Number).default('1'),
  pageSize: z.string().optional().transform(Number).default('20'),
});

export const contactEndpoints = {
  listContacts: endpoint({
    method: 'get',
    path: '/contacts',
    input: contactFilterSchema,
    output: z.object({
      contacts: z.array(z.object({
        id: z.string(),
        name: z.string(),
        phoneNumber: z.string(),
        isMyContact: z.boolean(),
        profilePicUrl: z.string().optional(),
        lastSeen: z.date().optional(),
        status: z.string().optional(),
      })),
      total: z.number(),
      page: z.number(),
      pageSize: z.number(),
    }),
    handler: async ({ input, options }) => {
      const whatsapp = options.whatsapp as WhatsAppService;
      
      if (!whatsapp.isReady()) {
        throw new Error('WhatsApp client is not ready');
      }

      const contacts = await whatsapp.getContacts();
      let filteredContacts = contacts;

      // Apply filters
      if (input.search) {
        const searchLower = input.search.toLowerCase();
        filteredContacts = contacts.filter(contact => 
          contact.name.toLowerCase().includes(searchLower) ||
          contact.phoneNumber.includes(searchLower)
        );
      }

      if (input.isMyContact !== undefined) {
        filteredContacts = contacts.filter(contact => 
          contact.isMyContact === input.isMyContact
        );
      }

      // Calculate pagination
      const startIndex = (input.page - 1) * input.pageSize;
      const endIndex = startIndex + input.pageSize;
      const paginatedContacts = filteredContacts.slice(startIndex, endIndex);

      return {
        contacts: paginatedContacts,
        total: filteredContacts.length,
        page: input.page,
        pageSize: input.pageSize,
      };
    },
  }),

  importContacts: endpoint({
    method: 'post',
    path: '/contacts/import',
    input: z.object({}),
    output: z.object({
      imported: z.number(),
      message: z.string(),
    }),
    handler: async ({ options }) => {
      const whatsapp = options.whatsapp as WhatsAppService;
      
      if (!whatsapp.isReady()) {
        throw new Error('WhatsApp client is not ready');
      }

      const imported = await whatsapp.syncContacts();
      
      return {
        imported,
        message: \`Successfully imported \${imported} contacts\`,
      };
    },
  }),
};

```

# backend/src/controllers/GroupController.ts

```ts
import { z } from 'zod';
import { createApi, endpoint } from 'express-zod-api';
import { WhatsAppService } from '../services/WhatsAppService';

const groupFilterSchema = z.object({
  search: z.string().optional(),
  isAdmin: z.string().optional().transform(val => val === 'true'),
  page: z.string().optional().transform(Number).default('1'),
  pageSize: z.string().optional().transform(Number).default('20'),
});

export const groupEndpoints = {
  listGroups: endpoint({
    method: 'get',
    path: '/groups',
    input: groupFilterSchema,
    output: z.object({
      groups: z.array(z.object({
        id: z.string(),
        name: z.string(),
        description: z.string().optional(),
        participants: z.array(z.object({
          id: z.string(),
          name: z.string(),
          phoneNumber: z.string(),
          isAdmin: z.boolean(),
        })),
        isAdmin: z.boolean(),
        profilePicUrl: z.string().optional(),
        createdAt: z.date(),
      })),
      total: z.number(),
      page: z.number(),
      pageSize: z.number(),
    }),
    handler: async ({ input, options }) => {
      const whatsapp = options.whatsapp as WhatsAppService;
      
      if (!whatsapp.isReady()) {
        throw new Error('WhatsApp client is not ready');
      }

      const groups = await whatsapp.getGroups();
      let filteredGroups = groups;

      // Apply filters
      if (input.search) {
        const searchLower = input.search.toLowerCase();
        filteredGroups = groups.filter(group => 
          group.name.toLowerCase().includes(searchLower) ||
          group.description?.toLowerCase().includes(searchLower)
        );
      }

      if (input.isAdmin !== undefined) {
        filteredGroups = groups.filter(group => 
          group.isAdmin === input.isAdmin
        );
      }

      // Calculate pagination
      const startIndex = (input.page - 1) * input.pageSize;
      const endIndex = startIndex + input.pageSize;
      const paginatedGroups = filteredGroups.slice(startIndex, endIndex);

      return {
        groups: paginatedGroups,
        total: filteredGroups.length,
        page: input.page,
        pageSize: input.pageSize,
      };
    },
  }),
};

```

# backend/src/entities/AdJob.ts

```ts
import { Entity, PrimaryGeneratedColumn, Column, ManyToOne, OneToMany } from "typeorm";

// Define the status type for better type safety
export type AdJobStatus = "pending" | "approved" | "rejected" | "running" | "completed" | "failed" | "stopped";

@Entity("ad_jobs")
export class AdJob {
  @PrimaryGeneratedColumn()
  id!: number;

  @ManyToOne("User", "adJobs", { lazy: true })
  user!: Promise<any>;

  @Column()
  userId!: number;

  @ManyToOne("MessageTemplate", "adJobs", { lazy: true })
  messageTemplate!: Promise<any>;

  @Column()
  templateId!: number;

  @Column({
    type: "text",
    enum: ["pending", "approved", "rejected", "running", "completed", "failed"]
  })
  status!: AdJobStatus;

  @Column({ type: "text" })
  audience!: string; // JSON string of selected contacts/groups

  @Column({ type: "integer", default: 0 })
  messagesSent!: number;

  @Column({ type: "integer", default: 0 })
  messagesDelivered!: number;

  @Column({ type: "text", nullable: true })
  schedule!: string; // JSON string of schedule settings

  @Column({ type: "datetime", default: () => "CURRENT_TIMESTAMP" })
  createdAt!: Date;

  @Column({ type: "datetime", default: () => "CURRENT_TIMESTAMP" })
  updatedAt!: Date;

  @OneToMany("ModerationLog", "adJob", { lazy: true })
  moderationLogs!: Promise<any>[];
}

```

# backend/src/entities/ContactGroup.ts

```ts
import { Entity, PrimaryGeneratedColumn, Column } from "typeorm";

@Entity("contacts_groups")
export class ContactGroup {
  @PrimaryGeneratedColumn()
  id!: number;

  @Column()
  name!: string;

  @Column({ nullable: true })
  phone!: string;

  @Column({ nullable: true, name: "group_id" })
  groupId!: string;

  @Column()
  type!: "contact" | "group";

  @Column({ type: "boolean", default: true })
  isActive!: boolean;

  @Column({ type: "datetime", default: () => "CURRENT_TIMESTAMP" })
  createdAt!: Date;

  @Column({ type: "datetime", default: () => "CURRENT_TIMESTAMP" })
  updatedAt!: Date;
}

```

# backend/src/entities/index.ts

```ts
export * from './AdJob';
export * from './ContactGroup';
export * from './MessageTemplate';
export * from './ModerationLog';
export * from './PhoneBook';
export * from './User';

```

# backend/src/entities/MessageTemplate.ts

```ts
import { Entity, PrimaryGeneratedColumn, Column, OneToMany } from "typeorm";

@Entity("message_templates")
export class MessageTemplate {
  @PrimaryGeneratedColumn()
  id!: number;

  @Column()
  title!: string;

  @Column({ type: "simple-array" })
  messages!: string[];

  @Column({ type: "datetime", default: () => "CURRENT_TIMESTAMP" })
  createdAt!: Date;

  @Column({ type: "datetime", default: () => "CURRENT_TIMESTAMP" })
  updatedAt!: Date;

  @OneToMany("AdJob", "messageTemplate", { lazy: true })
  adJobs!: Promise<any>[];
}

```

# backend/src/entities/ModerationLog.ts

```ts
import { Entity, PrimaryGeneratedColumn, Column, ManyToOne } from "typeorm";

// Define the action type for better type safety
export type ModerationAction = "approved" | "rejected" | "modified";

@Entity("moderation_logs")
export class ModerationLog {
  @PrimaryGeneratedColumn()
  id!: number;

  @ManyToOne("AdJob", "moderationLogs", { lazy: true })
  adJob!: Promise<any>;

  @Column()
  jobId!: number;

  @Column()
  moderator!: string;

  @Column({
    type: "text",
    enum: ["approved", "rejected", "modified"]
  })
  action!: ModerationAction;

  @Column({ type: "text", nullable: true })
  notes!: string;

  @Column({ type: "datetime", default: () => "CURRENT_TIMESTAMP" })
  createdAt!: Date;
}

```

# backend/src/entities/PhoneBook.ts

```ts
import { Entity, PrimaryGeneratedColumn, Column } from "typeorm";

@Entity("phone_book")
export class PhoneBook {
  @PrimaryGeneratedColumn()
  id!: number;

  @Column()
  name!: string;

  @Column()
  phone!: string;

  @Column({ name: "group_name", nullable: true })
  groupName!: string;

  @Column({ type: "datetime", default: () => "CURRENT_TIMESTAMP" })
  createdAt!: Date;

  @Column({ type: "datetime", default: () => "CURRENT_TIMESTAMP" })
  updatedAt!: Date;
}

```

# backend/src/entities/User.ts

```ts
import { Entity, PrimaryGeneratedColumn, Column, OneToMany } from "typeorm";

@Entity("users")
export class User {
  @PrimaryGeneratedColumn()
  id!: number;

  @Column()
  name!: string;

  @Column()
  phone!: string;

  @Column({ type: "text", nullable: true })
  session!: string;

  @OneToMany("AdJob", "user", { lazy: true })
  adJobs!: Promise<any>[];
}

```

# backend/src/index.ts

```ts
import { createConfig, createServer as createZodServer } from 'express-zod-api';
import { AppDataSource } from './config/database';
import { WebSocketManager } from './services/WebSocketManager';
import { WhatsAppService } from './services/WhatsAppService';
import { createRoutes } from './routes';
import path from 'path';
import dotenv from 'dotenv';
import fs from 'fs';

// Load environment variables
dotenv.config();

// Create data directory if it doesn't exist
const dataDir = path.join(__dirname, '../data');
if (!fs.existsSync(dataDir)) {
  fs.mkdirSync(dataDir, { recursive: true });
}

// Initialize database and start services
const startServer = async () => {
  try {
    let currentVersion: string | undefined;
    try {
      const res = await fetch("https://web.whatsapp.com/check-update?version=1&platform=web");
      const data = await res.json();
      currentVersion = (data as any).currentVersion;
    } catch(e) {
      console.error(e);
    }

    // Initialize express-zod-api with minimal config
    const config = createConfig({
      http: {
        listen: process.env.PORT ? parseInt(process.env.PORT) : 8000,
      },
      logger: {
        level: 'debug',
        color: true,
      },
      cors: ({
        defaultHeaders,
        request,
        endpoint,
        logger,
      }): Record<string, string> => {
        const origin = request.headers.origin;
        const allowedOrigin =
          (origin && new URL(origin).origin) || request.hostname || "*";
    
        return {
          ...defaultHeaders,
          // 'Access-Control-Allow-Origin': new URL(swaggerBaseUrl).origin!,
          "Access-Control-Allow-Origin": allowedOrigin, // handle proxied requests
          "Access-Control-Allow-Credentials": "true", // Allow credentials
          "Access-Control-Allow-Headers":
            "Authorization, Content-Type, Accept, Origin, X-Requested-With, Access-Control-Allow-Origin, Access-Control-Allow-Credentials, Access-Control-Allow-Methods, Access-Control-Allow-Headers, x-access-key",
        };
      },
    });

    // Initialize database
    await AppDataSource.initialize();
    console.log('Database connection established');

    const wa: { whatsappService: WhatsAppService | null, wsManager: WebSocketManager | null } = { whatsappService: null, wsManager: null };
    // Create API routes
    const routing = createRoutes(wa);
    const { app, servers } = await createZodServer(config, routing);
    const server = servers[0];

    // Initialize WebSocket Manager
    const wsManager = new WebSocketManager(server);

    // Initialize WhatsApp Service
    const whatsappService = new WhatsAppService(wsManager, { currentVersion });

    wa.whatsappService = whatsappService;
    wa.wsManager = wsManager;

    // Initialize WhatsApp client
    whatsappService.initialize().then(() => 
      console.log('WhatsApp client initialized'));
  } catch (error) {
    console.error('Failed to start server:', error);
    process.exit(1);
  }
};

startServer();

```

# backend/src/migrations/01_template_content_to_messages.ts

```ts
import { AppDataSource } from '../config/database';
import { MessageTemplate } from '../entities/MessageTemplate';

export async function migrate() {
  const templateRepo = AppDataSource.getRepository(MessageTemplate);
  
  // Get all existing templates
  const templates = await templateRepo.find();
  
  // Convert each template's content to messages array
  for (const template of templates) {
    // @ts-ignore - accessing old content field
    if (template.content && !template.messages) {
      // @ts-ignore - accessing old content field
      template.messages = [template.content];
      // @ts-ignore - accessing old content field
      delete template.content;
      await templateRepo.save(template);
    }
  }
  
  console.log(`[Migration] Successfully migrated ${templates.length} templates from content to messages`);
}

```

# backend/src/routes/index.ts

```ts
import { Routing, defaultEndpointsFactory, Middleware } from 'express-zod-api';
import { z } from 'zod';
import { AdJob, AdJobStatus } from '../entities/AdJob';
import { MessageTemplate } from '../entities/MessageTemplate';
import { User } from '../entities/User';
import { ModerationLog, ModerationAction } from '../entities/ModerationLog';
import { ContactGroup } from '../entities/ContactGroup';
import { PhoneBook } from '../entities/PhoneBook';
import { AppDataSource } from '../config/database';
import { WhatsAppService } from '../services/WhatsAppService';
import { WebSocketManager } from '../services/WebSocketManager';

const zBooleanInput = () => z.string().transform(s => s === "true" ? true : false);

// Define input/output schemas
const contactSchema = z.object({
  id: z.string(),
  name: z.string(),
  phoneNumber: z.string(),
  isMyContact: z.boolean(),
  profilePicUrl: z.string().optional(),
  status: z.string().optional(),
});

const groupSchema = z.object({
  id: z.string(),
  name: z.string(),
  description: z.string().optional(),
  participants: z.array(z.object({
    id: z.string(),
    name: z.string(),
    phoneNumber: z.string(),
    isAdmin: z.boolean(),
  })),
  isAdmin: z.boolean(),
  profilePicUrl: z.string().optional(),
  createdAt: z.date(),
});

const adJobSchema = z.object({
  templateId: z.number(),
  audience: z.string(),
  status: z.enum(['pending', 'approved', 'rejected', 'running', 'completed', 'failed', 'stopped'] as const),
});

const messageTemplateSchema = z.object({
  title: z.string(),
  messages: z.array(z.string()),
});

const userSchema = z.object({
  name: z.string(),
  phone: z.string(),
  session: z.string().nullable(),
});

const moderationLogSchema = z.object({
  jobId: z.number(),
  moderator: z.string(),
  action: z.enum(['approved', 'rejected', 'modified'] as const),
  notes: z.string().optional(),
});

const contactGroupSchema = z.object({
  name: z.string(),
  phone: z.string().optional(),
  groupId: z.string().optional(),
  type: z.enum(['contact', 'group'] as const),
  isActive: z.boolean().optional(),
});

const phoneBookSchema = z.object({
  name: z.string(),
  phone: z.string(),
  groupName: z.string().optional(),
});

type Options = {
  whatsappService: WhatsAppService;
  wsManager?: WebSocketManager;
};

// Create endpoints
export const createRoutes = (wa: { whatsappService: WhatsAppService | null, wsManager: WebSocketManager | null }): Routing => {
  const e = defaultEndpointsFactory.addMiddleware(new Middleware<any, Options, string, any>({
    handler: async ({ request: req, response: res }) => {
      return { whatsappService: wa.whatsappService!, wsManager: wa.wsManager! };
    },
  }));

  const routing: Routing = {
    api: {
      whatsapp: {
        contacts: e.build({
          method: 'get',
          input: z.object({
            page: z.string().transform(s => Number(s)).optional().default("1"),
            pageSize: z.string().transform(s => Number(s)).optional().default("20"),
          }),
          output: z.object({
            items: z.array(contactSchema),
            total: z.number(),
            page: z.number(),
            pageSize: z.number(),
          }),
          handler: async ({ input, options }) => {
            if (!options.whatsappService.isConnected()) {
              throw new Error('WhatsApp client is not connected');
            }

            const contacts = await options.whatsappService.getContacts();
            const startIndex = (input.page - 1) * input.pageSize;
            const endIndex = startIndex + input.pageSize;
            
            return {
              items: contacts.slice(startIndex, endIndex),
              total: contacts.length,
              page: input.page,
              pageSize: input.pageSize,
            };
          },
        }),
        groups: e.build({
          method: 'get',
          input: z.object({
            page: z.string().transform(s => Number(s)).optional().default("1"),
            pageSize: z.string().transform(s => Number(s)).optional().default("20"),
          }),
          output: z.object({
            items: z.array(groupSchema),
            total: z.number(),
            page: z.number(),
            pageSize: z.number(),
          }),
          handler: async ({ input, options }) => {
            if (!options.whatsappService.isConnected()) {
              throw new Error('WhatsApp client is not connected');
            }

            const groups = await options.whatsappService.getGroups();
            const startIndex = (input.page - 1) * input.pageSize;
            const endIndex = startIndex + input.pageSize;
            
            return {
              items: groups.slice(startIndex, endIndex),
              total: groups.length,
              page: input.page,
              pageSize: input.pageSize,
            };
          },
        }),
        status: e.build({
          method: 'get',
          input: z.object({}),
          output: z.object({
            connected: z.boolean(),
            qrCode: z.string().nullable(),
            connectedClients: z.number(),
          }),
          handler: async ({ options }) => ({
            connected: options.whatsappService.isConnected(),
            qrCode: options.whatsappService.getQRCode(),
            connectedClients: options.wsManager?.getConnectedClients() ?? 0,
          }),
        }),
      },
      templates: {
        list: e.build({
          method: 'get',
          input: z.object({}),
          output: z.object({
            items: z.array(messageTemplateSchema.extend({ id: z.number(), createdAt: z.date(), updatedAt: z.date() })),
          }),
          handler: async () => {
            const templateRepo = AppDataSource.getRepository(MessageTemplate);
            const templates = await templateRepo.find({
              order: { createdAt: 'DESC' },
            });
            return { items: templates.map(t => ({
              id: t.id,
              title: t.title,
              messages: t.messages,
              createdAt: t.createdAt,
              updatedAt: t.updatedAt
            })) };
          },
        }),
        create: e.build({
          method: 'post',
          input: messageTemplateSchema,
          output: messageTemplateSchema.extend({ id: z.number(), createdAt: z.date(), updatedAt: z.date() }),
          handler: async ({ input }) => {
            const templateRepo = AppDataSource.getRepository(MessageTemplate);
            const template = templateRepo.create(input);
            const savedTemplate = await templateRepo.save(template) as unknown as MessageTemplate;
            return savedTemplate;
          },
        }),
        update: e.build({
          method: 'put',
          input: z.object({
            id: z.number(),
            template: messageTemplateSchema,
          }),
          output: messageTemplateSchema.extend({ id: z.number(), createdAt: z.date(), updatedAt: z.date() }),
          handler: async ({ input }) => {
            const templateRepo = AppDataSource.getRepository(MessageTemplate);
            const template = await templateRepo.findOneBy({ id: input.id });
            if (!template) {
              throw new Error('Template not found');
            }
            
            // Update fields
            template.title = input.template.title;
            template.messages = input.template.messages;
            template.updatedAt = new Date();
            
            const savedTemplate = await templateRepo.save(template);
            return savedTemplate;
          },
        }),
        delete: e.build({
          method: 'delete',
          input: z.object({
            id: z.string().transform(s => Number(s)),
          }),
          output: z.object({
            success: z.boolean(),
          }),
          handler: async ({ input }) => {
            const templateRepo = AppDataSource.getRepository(MessageTemplate);
            await templateRepo.delete(input.id);
            return { success: true };
          },
        }),
      },
      ads: {
        create: e.build({
          method: 'post',
          input: adJobSchema,
          output: adJobSchema.extend({ id: z.number() }),
          handler: async ({ input, options }) => {
            const adJobRepo = AppDataSource.getRepository(AdJob);
            const newJob = adJobRepo.create(input);
            const [savedJob] = await adJobRepo.save(newJob);
            
            // Broadcast ad job creation
            options.wsManager?.broadcast('ad:status', {
              id: savedJob.id,
              status: savedJob.status,
              templateId: savedJob.templateId,
              audience: savedJob.audience,
            });
            
            return {
              id: savedJob.id,
              templateId: savedJob.templateId,
              audience: savedJob.audience,
              status: savedJob.status,
            };
          },
        }),
        list: e.build({
          method: 'get',
          input: z.object({
            status: z.enum(['pending', 'approved', 'rejected', 'running', 'completed', 'failed'] as const).optional(),
          }),
          output: z.object({
            items: z.array(adJobSchema.extend({ id: z.number() })),
          }),
          handler: async ({ input }) => {
            const adJobRepo = AppDataSource.getRepository(AdJob);
            const query = adJobRepo.createQueryBuilder('adJob');
            
            if (input.status) {
              query.where('adJob.status = :status', { status: input.status });
            }
            
            const jobs = await query.getMany();
            const items = jobs.map(job => ({
              id: job.id,
              templateId: job.templateId,
              audience: job.audience,
              status: job.status,
            }));
            return { items };
          },
        }),
      },
      users: {
        create: e.build({
          method: 'post',
          input: userSchema,
          output: userSchema.extend({ id: z.number() }),
          handler: async ({ input }) => {
            const userRepo = AppDataSource.getRepository(User);
            const newUser = userRepo.create(input);
            const [savedUser] = await userRepo.save(newUser);
            return {
              id: savedUser.id,
              name: savedUser.name,
              phone: savedUser.phone,
              session: savedUser.session,
            };
          },
        }),
        list: e.build({
          method: 'get',
          input: z.object({}),
          output: z.object({
            items: z.array(userSchema.extend({ id: z.number() })),
          }),
          handler: async () => {
            const userRepo = AppDataSource.getRepository(User);
            const users = await userRepo.find();
            return {
              items: users.map(user => ({
                id: user.id,
                name: user.name,
                phone: user.phone,
                session: user.session,
              })),
            };
          },
        }),
      },
      moderation: {
        create: e.build({
          method: 'post',
          input: moderationLogSchema,
          output: moderationLogSchema.extend({ id: z.number() }),
          handler: async ({ input, options }) => {
            const moderationRepo = AppDataSource.getRepository(ModerationLog);
            const adJobRepo = AppDataSource.getRepository(AdJob);
            
            // Update ad job status based on moderation action
            const adJob = await adJobRepo.findOneBy({ id: input.jobId });
            if (!adJob) {
              throw new Error('Ad job not found');
            }
            
            adJob.status = input.action === 'approved' ? 'approved' : 'rejected';
            const updatedJob = await adJobRepo.save(adJob);
            
            // Broadcast moderation update
            options.wsManager?.broadcast('ad:status', {
              id: updatedJob.id,
              status: updatedJob.status,
              action: input.action,
              moderator: input.moderator,
            });
            
            // Create moderation log
            const newLog = moderationRepo.create(input);
            const [savedLog] = await moderationRepo.save(newLog);
            return {
              id: savedLog.id,
              jobId: savedLog.jobId,
              moderator: savedLog.moderator,
              action: savedLog.action,
              notes: savedLog.notes,
            };
          },
        }),
        list: e.build({
          method: 'get',
          input: z.object({
            jobId: z.string().transform(s=>Number(s)).optional(),
          }),
          output: z.object({
            items: z.array(moderationLogSchema.extend({ id: z.number() })),
          }),
          handler: async ({ input }) => {
            const moderationRepo = AppDataSource.getRepository(ModerationLog);
            const query = moderationRepo.createQueryBuilder('log');
            
            if (input.jobId) {
              query.where('log.jobId = :jobId', { jobId: input.jobId });
            }
            
            const logs = await query.getMany();
            return {
              items: logs.map(log => ({
                id: log.id,
                jobId: log.jobId,
                moderator: log.moderator,
                action: log.action,
                notes: log.notes,
              })),
            };
          },
        }),
      },
      contactGroups: {
        create: e.build({
          method: 'post',
          input: contactGroupSchema,
          output: contactGroupSchema.extend({ id: z.number() }),
          handler: async ({ input }) => {
            const contactRepo = AppDataSource.getRepository(ContactGroup);
            const newContact = contactRepo.create({
              ...input,
              type: 'contact',
            });
            const [savedContact] = await contactRepo.save(newContact);
            return {
              id: savedContact.id,
              name: savedContact.name,
              phone: savedContact.phone,
              groupId: savedContact.groupId,
              type: savedContact.type,
              isActive: savedContact.isActive,
            };
          },
        }),
        list: e.build({
          method: 'get',
          input: z.object({
            type: z.enum(['contact', 'group'] as const).optional(),
            isActive: zBooleanInput().optional(),
          }),
          output: z.object({
            items: z.array(contactGroupSchema.extend({ id: z.number() })),
          }),
          handler: async ({ input }) => {
            const contactRepo = AppDataSource.getRepository(ContactGroup);
            const query = contactRepo.createQueryBuilder('contact');
            
            if (input.type) {
              query.where('contact.type = :type', { type: input.type });
            }
            
            if (input.isActive !== undefined) {
              query.andWhere('contact.isActive = :isActive', { isActive: input.isActive });
            }
            
            const contacts = await query.getMany();
            return {
              items: contacts.map(contact => ({
                id: contact.id,
                name: contact.name,
                phone: contact.phone,
                groupId: contact.groupId,
                type: contact.type,
                isActive: contact.isActive,
              })),
            };
          },
        }),
      },
      whatsappGroups: {
        create: e.build({
          method: 'post',
          input: contactGroupSchema,
          output: contactGroupSchema.extend({ id: z.number() }),
          handler: async ({ input }) => {
            const groupRepo = AppDataSource.getRepository(ContactGroup);
            const newGroup = groupRepo.create({
              ...input,
              type: 'group',
            });
            const [savedGroup] = await groupRepo.save(newGroup);
            return {
              id: savedGroup.id,
              name: savedGroup.name,
              groupId: savedGroup.groupId,
              type: savedGroup.type,
              isActive: savedGroup.isActive,
            };
          },
        }),
        list: e.build({
          method: 'get',
          input: z.object({
            isActive: zBooleanInput().optional(),
          }),
          output: z.object({
            items: z.array(contactGroupSchema.extend({ id: z.number() })),
          }),
          handler: async ({ input }) => {
            const groupRepo = AppDataSource.getRepository(ContactGroup);
            const query = groupRepo.createQueryBuilder('group')
              .where('group.type = :type', { type: 'group' });
            
            if (input.isActive !== undefined) {
              query.andWhere('group.isActive = :isActive', { isActive: input.isActive });
            }
            
            const groups = await query.getMany();
            return {
              items: groups.map(group => ({
                id: group.id,
                name: group.name,
                groupId: group.groupId,
                type: group.type,
                isActive: group.isActive,
              })),
            };
          },
        }),
      },
      phonebook: {
        create: e.build({
          method: 'post',
          input: phoneBookSchema,
          output: phoneBookSchema.extend({ id: z.number() }),
          handler: async ({ input }) => {
            const phoneBookRepo = AppDataSource.getRepository(PhoneBook);
            const newEntry = phoneBookRepo.create(input);
            const [savedEntry] = await phoneBookRepo.save(newEntry);
            return {
              id: savedEntry.id,
              name: savedEntry.name,
              phone: savedEntry.phone,
              groupName: savedEntry.groupName,
            };
          },
        }),
        list: e.build({
          method: 'get',
          input: z.object({
            groupName: z.string().optional(),
          }),
          output: z.object({
            items: z.array(phoneBookSchema.extend({ id: z.number() })),
          }),
          handler: async ({ input }) => {
            const phoneBookRepo = AppDataSource.getRepository(PhoneBook);
            const query = phoneBookRepo.createQueryBuilder('entry');
            
            if (input.groupName) {
              query.where('entry.groupName = :groupName', { groupName: input.groupName });
            }
            
            const entries = await query.getMany();
            return {
              items: entries.map(entry => ({
                id: entry.id,
                name: entry.name,
                phone: entry.phone,
                groupName: entry.groupName,
              })),
            };
          },
        }),
      },

    },
  };

  return routing;
};

export default createRoutes;

```

# backend/src/scripts/run-migrations.ts

```ts
import { AppDataSource } from '../config/database';
import { migrate as templateMigration } from '../migrations/01_template_content_to_messages';

async function runMigrations() {
  try {
    // Initialize database connection
    await AppDataSource.initialize();
    console.log('Database connection initialized');

    // Run migrations in sequence
    console.log('Starting migrations...');
    
    // Template content to messages migration
    console.log('\nRunning: Template content to messages migration');
    await templateMigration();
    
    console.log('\nAll migrations completed successfully');
    process.exit(0);
  } catch (error) {
    console.error('Migration failed:', error);
    process.exit(1);
  }
}

// Run migrations
runMigrations();

```

# backend/src/services/RateLimiterService.ts

```ts
import { EventEmitter } from 'events';

interface RateLimitConfig {
  messagesPerMinute: number;
  burstSize: number;
  cooldownMinutes: number;
}

interface TokenBucket {
  tokens: number;
  lastRefill: number;
  cooldownUntil?: number;
}

export class RateLimiterService extends EventEmitter {
  private buckets: Map<string, TokenBucket> = new Map();
  private config: RateLimitConfig;

  constructor(config: Partial<RateLimitConfig> = {}) {
    super();
    this.config = {
      messagesPerMinute: config.messagesPerMinute || 30, // WhatsApp's default rate limit
      burstSize: config.burstSize || 10,
      cooldownMinutes: config.cooldownMinutes || 15,
    };
  }

  public async canSendMessage(phoneNumber: string): Promise<boolean> {
    const bucket = this.getBucket(phoneNumber);
    
    // Check if in cooldown
    if (bucket.cooldownUntil && Date.now() < bucket.cooldownUntil) {
      return false;
    }

    // Refill tokens based on time elapsed
    this.refillTokens(bucket);

    // Check if we have tokens available
    if (bucket.tokens > 0) {
      bucket.tokens--;
      return true;
    }

    // No tokens available, enter cooldown
    bucket.cooldownUntil = Date.now() + (this.config.cooldownMinutes * 60 * 1000);
    this.emit('cooldown:start', { phoneNumber, cooldownUntil: bucket.cooldownUntil });
    return false;
  }

  private getBucket(phoneNumber: string): TokenBucket {
    if (!this.buckets.has(phoneNumber)) {
      this.buckets.set(phoneNumber, {
        tokens: this.config.burstSize,
        lastRefill: Date.now(),
      });
    }
    return this.buckets.get(phoneNumber)!;
  }

  private refillTokens(bucket: TokenBucket): void {
    const now = Date.now();
    const timePassed = now - bucket.lastRefill;
    const tokensToAdd = Math.floor((timePassed / 60000) * this.config.messagesPerMinute);

    if (tokensToAdd > 0) {
      bucket.tokens = Math.min(bucket.tokens + tokensToAdd, this.config.burstSize);
      bucket.lastRefill = now;
    }
  }

  public getRemainingTokens(phoneNumber: string): number {
    const bucket = this.getBucket(phoneNumber);
    this.refillTokens(bucket);
    return bucket.tokens;
  }

  public getCooldownTime(phoneNumber: string): number | null {
    const bucket = this.getBucket(phoneNumber);
    if (bucket.cooldownUntil && Date.now() < bucket.cooldownUntil) {
      return bucket.cooldownUntil - Date.now();
    }
    return null;
  }
}

```

# backend/src/services/WebSocketManager.ts

```ts
import WebSocket from 'ws';
import { Server } from 'http';
import { EventEmitter } from 'events';
import { WSEventType, WSMessage } from '@shared/types/websocket';

const debug = (message: string, ...args: any[]) => {
  console.log(`[WebSocket Server] ${message}`, ...args);
};

const debugError = (message: string, ...args: any[]) => {
  console.error(`[WebSocket Server Error] ${message}`, ...args);
};

export class WebSocketManager extends EventEmitter {
  private wss: WebSocket.Server;
  private clients: Set<WebSocket> = new Set();
  private whatsAppService: {
    getQRCode: () => string | null;
    isConnected: () => boolean;
  } | null = null; // Will be set by setWhatsAppService
  private messageStats = {
    received: 0,
    sent: 0,
    errors: 0
  };

  public setWhatsAppService(service: {
    getQRCode: () => string | null;
    isConnected: () => boolean;
  }) {
    debug('Setting WhatsApp service');
    this.whatsAppService = service;
  }

  constructor(server: Server) {
    super();
    this.wss = new WebSocket.Server({ server });
    this.setupWebSocket();
    this.startStatsReporting();
  }

  private setupWebSocket() {
    this.wss.on('connection', (ws: WebSocket, req) => {
      const clientIp = req.socket.remoteAddress;
      debug('New client connected', { ip: clientIp, totalClients: this.clients.size + 1 });
      this.clients.add(ws);

      // Send initial connection success
      this.sendTo(ws, 'connection:established', {
        timestamp: new Date(),
        stats: this.messageStats,
        clientsConnected: this.clients.size
      });

      // Send initial WhatsApp state to the client
      if (this.whatsAppService) {
        const isConnected = this.whatsAppService.isConnected();
        const currentQR = this.whatsAppService.getQRCode();

        debug('Sending initial WhatsApp state to client:', {
          isConnected,
          hasQRCode: Boolean(currentQR)
        });

        // Send current QR code if available and not connected
        if (currentQR && !isConnected) {
          this.sendTo(ws, 'whatsapp:qr', { qr: currentQR });
        }

        // Send connected state if connected
        if (isConnected) {
          this.sendTo(ws, 'whatsapp:ready', { timestamp: new Date() });
        }
      }

      ws.on('message', (message: string) => {
        try {
          const parsed: WSMessage = JSON.parse(message.toString());
          this.messageStats.received++;

          debug('Received message', {
            type: parsed.type,
            data: parsed.data,
            stats: this.messageStats
          });

          // Echo back test messages
          if (parsed.type === 'ad:status' && parsed.data.status === 'test') {
            this.sendTo(ws, 'ad:status', {
              ...parsed.data,
              echo: true,
              serverTimestamp: new Date().toISOString()
            });
          }

          this.emit('message', parsed);
        } catch (error) {
          this.messageStats.errors++;
          debugError('Failed to parse message:', error);
        }
      });

      ws.on('close', (code, reason) => {
        debug('Client disconnected', {
          ip: clientIp,
          code,
          reason: reason.toString(),
          remainingClients: this.clients.size - 1
        });
        this.clients.delete(ws);
      });

      ws.on('error', (error) => {
        this.messageStats.errors++;
        debugError('Client error:', { ip: clientIp, error });
        this.clients.delete(ws);
      });
    });
  }

  private startStatsReporting() {
    setInterval(() => {
      debug('WebSocket Stats', {
        clients: this.clients.size,
        ...this.messageStats
      });
    }, 60000); // Report every minute
  }

  public broadcast(type: WSEventType, data: any) {
    const message = JSON.stringify({ type, data });
    let sentCount = 0;
    let failedCount = 0;

    this.clients.forEach(client => {
      if (client.readyState === WebSocket.OPEN) {
        try {
          client.send(message);
          sentCount++;
          this.messageStats.sent++;
        } catch (error) {
          failedCount++;
          debugError('Failed to send to client:', error);
          // Remove failed client
          this.clients.delete(client);
        }
      } else if (client.readyState === WebSocket.CLOSED || client.readyState === WebSocket.CLOSING) {
        // Clean up closed connections
        this.clients.delete(client);
      }
    });

    debug('Broadcast message', {
      type,
      data: type === 'whatsapp:qr' ? { qrLength: data.qr?.length } : data,
      recipients: sentCount,
      failed: failedCount,
      totalClients: this.clients.size
    });
  }

  public sendTo(client: WebSocket, type: WSEventType, data: any) {
    if (client.readyState === WebSocket.OPEN) {
      const message = JSON.stringify({ type, data });
      client.send(message);
      this.messageStats.sent++;

      debug('Sent message', { type, data });
    } else {
      debugError('Cannot send - client not ready', {
        readyState: client.readyState
      });
    }
  }

  public getConnectedClients(): number {
    return this.clients.size;
  }

  public getStats() {
    return {
      ...this.messageStats,
      clients: this.clients.size
    };
  }
}

```

# backend/src/services/WebSocketService.ts

```ts
import WebSocket, { Server as WebSocketServer } from 'ws';
import { Server } from 'http';
import { AdJob } from '../entities/AdJob';
import { ModerationLog } from '../entities/ModerationLog';

export type WebSocketMessage = {
  type: 'whatsapp_status' | 'ad_job_update' | 'moderation_update';
  data: any;
};

export class WebSocketService {
  private wss: WebSocketServer;
  private clients: Set<WebSocket> = new Set();

  constructor(server: Server) {
    this.wss = new WebSocketServer({ server });
    this.setupWebSocket();
  }

  private setupWebSocket() {
    this.wss.on('connection', (ws: WebSocket) => {
      // Add new client
      this.clients.add(ws);

      // Remove client on disconnect
      ws.on('close', () => {
        this.clients.delete(ws);
      });

      // Handle incoming messages
      ws.on('message', (message: string) => {
        try {
          const parsedMessage = JSON.parse(message);
          this.handleMessage(ws, parsedMessage);
        } catch (error) {
          console.error('Error parsing WebSocket message:', error);
        }
      });
    });
  }

  private handleMessage(ws: WebSocket, message: any) {
    // Handle different message types
    switch (message.type) {
      case 'ping':
        ws.send(JSON.stringify({ type: 'pong' }));
        break;
      default:
        console.warn('Unknown message type:', message.type);
    }
  }

  public broadcastWhatsAppStatus(connected: boolean, qrCode: string | null) {
    const message: WebSocketMessage = {
      type: 'whatsapp_status',
      data: { connected, qrCode },
    };
    this.broadcast(message);
  }

  public broadcastAdJobUpdate(adJob: AdJob) {
    const message: WebSocketMessage = {
      type: 'ad_job_update',
      data: {
        id: adJob.id,
        templateId: adJob.templateId,
        audience: adJob.audience,
        status: adJob.status,
      },
    };
    this.broadcast(message);
  }

  public broadcastModerationUpdate(log: ModerationLog) {
    const message: WebSocketMessage = {
      type: 'moderation_update',
      data: {
        id: log.id,
        jobId: log.jobId,
        moderator: log.moderator,
        action: log.action,
        notes: log.notes,
      },
    };
    this.broadcast(message);
  }

  private broadcast(message: WebSocketMessage) {
    const messageStr = JSON.stringify(message);
    this.clients.forEach(client => {
      if (client.readyState === WebSocket.OPEN) {
        client.send(messageStr);
      }
    });
  }
}

```

# backend/src/services/WhatsAppService.ts

```ts
import { Client, LocalAuth, Chat, Contact } from 'whatsapp-web.js';
import { WebSocketManager } from './WebSocketManager';
import { RateLimiterService } from './RateLimiterService';
import { EventEmitter } from 'events';
import qrcode from 'qrcode-terminal';

interface ExtendedChat extends Chat {
  participants: Array<{
    id: { _serialized: string };
    isAdmin?: boolean;
    isSuperAdmin?: boolean;
  }>;
  description?: string;
  createdAt: Date;
  getProfilePicUrl(): Promise<string>;
}

interface ContactData {
  id: string;
  name: string;
  phoneNumber: string;
  isMyContact: boolean;
  profilePicUrl?: string;
  status?: string;
}

interface GroupData {
  id: string;
  name: string;
  description?: string;
  participants: Array<{
    id: string;
    name: string;
    phoneNumber: string;
    isAdmin: boolean;
  }>;
  isAdmin: boolean;
  profilePicUrl?: string;
  createdAt: Date;
}

export class WhatsAppService extends EventEmitter {
  private client: Client;
  private wsManager: WebSocketManager;
  private rateLimiter: RateLimiterService;
  private isReady: boolean = false;
  private currentQRCode: string | null = null;
  private contacts: Map<string, ContactData> = new Map();
  private groups: Map<string, GroupData> = new Map();
  constructor(wsManager: WebSocketManager, { currentVersion }: { currentVersion?: string }) {
    super();
    this.wsManager = wsManager;
    this.rateLimiter = new RateLimiterService();
    this.client = new Client({
      takeoverOnConflict: true,
      authStrategy: new LocalAuth(),
      puppeteer: {
        args: ['--no-sandbox']
      },
      webVersion: currentVersion ?? "2.2413.51", // retrieve the latest using this url: https://web.whatsapp.com/check-update?version=1&platform=web
    });

    // Register this service with the WebSocket manager
    this.wsManager.setWhatsAppService(this);

    this.setupEventListeners();
    this.setupRateLimiterEvents();
  }

  private setupRateLimiterEvents() {
    this.rateLimiter.on('cooldown:start', ({ phoneNumber, cooldownUntil }) => {
      this.wsManager.broadcast('ad:progress', {
        type: 'rate_limit',
        phoneNumber,
        cooldownUntil,
        message: `Rate limit reached for ${phoneNumber}. Cooling down until ${new Date(cooldownUntil).toLocaleString()}`
      });
    });
  }

  private setupEventListeners() {
    this.client.on('qr', (qr) => {
      if (!qr) {
        console.error('[WhatsAppService] Received invalid QR code');
        return;
      }

      console.log('[WhatsAppService] Received QR code:', {
        length: qr.length,
        start: qr.slice(0, 20)
      });

      // Reset connection state when new QR code is received
      this.isReady = false;
      this.currentQRCode = qr;
      
      // Generate QR in terminal for development purposes
      qrcode.generate(qr, { small: true });
      
      // Send QR to frontend via WebSocket
      console.log('[WhatsAppService] Broadcasting QR code to frontend');
      this.wsManager.broadcast('whatsapp:qr', { qr });
      
      // Verify broadcast was sent
      const connectedClients = this.wsManager.getConnectedClients();
      console.log('[WhatsAppService] QR code broadcast status:', {
        connectedClients,
        qrLength: qr.length,
        qrStart: qr.slice(0, 20),
        isReady: this.isReady
      });
    });

    this.client.on('ready', async () => {
      console.log('[WhatsAppService] WhatsApp client ready');
      this.isReady = true;
      this.currentQRCode = null;

      // Sync contacts and groups when ready
      await this.syncContacts();
      await this.syncGroups();

      this.wsManager.broadcast('whatsapp:ready', {
        timestamp: new Date(),
        isConnected: true
      });
    });

    this.client.on('authenticated', () => {
      console.log('[WhatsAppService] WhatsApp client authenticated');
      this.currentQRCode = null;
      this.wsManager.broadcast('whatsapp:authenticated', {
        timestamp: new Date(),
        isConnected: this.isReady
      });
    });

    this.client.on('disconnected', () => {
      console.log('[WhatsAppService] WhatsApp client disconnected');
      this.isReady = false;
      this.contacts.clear();
      this.groups.clear();
      // Don't clear QR code on disconnect to avoid flashing
      // this.currentQRCode = null;
      this.wsManager.broadcast('whatsapp:disconnected', {
        timestamp: new Date(),
        isConnected: false
      });
    });

    // Listen for contact and group updates
    this.client.on('contact_changed', async (contact: Contact) => {
      if (contact.id && contact.id._serialized) {
        await this.updateContact(contact);
      }
    });

    this.client.on('group_join', async (notification) => {
      await this.syncGroups();
    });

    this.client.on('group_leave', async (notification) => {
      await this.syncGroups();
    });

    this.client.on('group_update', async (notification) => {
      await this.syncGroups();
    });
  }

  public async syncContacts(): Promise<number> {
    if (!this.isReady) {
      throw new Error('WhatsApp client is not ready');
    }

    try {
      const contacts = await this.client.getContacts();
      this.contacts.clear();

      for (const contact of contacts) {
        await this.updateContact(contact);
      }

      console.log(`[WhatsAppService] Synced ${this.contacts.size} contacts`);
      return this.contacts.size;
    } catch (error) {
      console.error('[WhatsAppService] Error syncing contacts:', error);
      throw error;
    }
  }

  private async updateContact(contact: Contact): Promise<ContactData | undefined> {
    if (!contact.id || !contact.id._serialized) return;

    const contactData: ContactData = {
      id: contact.id._serialized,
      name: contact.name || contact.pushname || contact.number,
      phoneNumber: contact.number,
      isMyContact: contact.isMyContact,
      profilePicUrl: await contact.getProfilePicUrl().catch(() => undefined),
      // Note: getStatus is not available in the current version, so we'll skip it
      status: undefined,
    };

    this.contacts.set(contactData.id, contactData);
    return contactData;
  }

  public async getContacts(): Promise<ContactData[]> {
    if (!this.isReady) {
      throw new Error('WhatsApp client is not ready');
    }

    return Array.from(this.contacts.values());
  }

  public async syncGroups(): Promise<number> {
    if (!this.isReady) {
      throw new Error('WhatsApp client is not ready');
    }

    try {
      const chats = await this.client.getChats();
      const groups = chats.filter(chat => chat.isGroup) as ExtendedChat[];
      this.groups.clear();

      for (const group of groups) {
        const participants = await Promise.all(
          group.participants.map(async (participant) => {
            const contact = await this.client.getContactById(participant.id._serialized) as Contact;
            return {
              id: participant.id._serialized,
              name: contact.name || contact.pushname || contact.number,
              phoneNumber: contact.number,
              isAdmin: participant.isAdmin || participant.isSuperAdmin || false,
            };
          })
        );

        const groupData: GroupData = {
          id: group.id._serialized,
          name: group.name,
          description: group.description,
          participants,
          isAdmin: group.participants.find(
            (p) => p.id._serialized === this.client.info.wid._serialized
          )?.isAdmin || false,
          profilePicUrl: await group.getProfilePicUrl().catch(() => undefined),
          createdAt: group.createdAt,
        };

        this.groups.set(groupData.id, groupData);
      }

      console.log(`[WhatsAppService] Synced ${this.groups.size} groups`);
      return this.groups.size;
    } catch (error) {
      console.error('[WhatsAppService] Error syncing groups:', error);
      throw error;
    }
  }

  public async getGroups(): Promise<GroupData[]> {
    if (!this.isReady) {
      throw new Error('WhatsApp client is not ready');
    }

    return Array.from(this.groups.values());
  }
  public async initialize(): Promise<void> {
    try {
      console.log('[WhatsAppService] Initializing WhatsApp client...');
      await this.client.initialize();
      console.log('[WhatsAppService] WhatsApp client initialized successfully');

      // After initialization, if we're not ready and don't have a QR code,
      // notify clients that we're waiting for QR
      if (!this.isReady && !this.currentQRCode) {
        this.wsManager.broadcast('whatsapp:status', {
          status: 'waiting_for_qr',
          timestamp: new Date()
        });
      }
    } catch (error) {
      console.error('[WhatsAppService] Failed to initialize WhatsApp client:', error);
      // Reset state
      this.isReady = false;
      this.currentQRCode = null;

      // Notify frontend of initialization error
      this.wsManager.broadcast('whatsapp:error', {
        message: 'Failed to initialize WhatsApp client',
        error: error instanceof Error ? error.message : String(error)
      });
      throw error;
    }
  }

  public async sendMessage(to: string, content: string | string[]): Promise<void> {
    if (!this.isReady) {
      throw new Error('WhatsApp client is not ready');
    }

    try {
      const formattedNumber = this.formatPhoneNumber(to);
      const messages = Array.isArray(content) ? content : [content];
      
      // Check rate limit for all messages
      for (let i = 0; i < messages.length; i++) {
        const canSend = await this.rateLimiter.canSendMessage(formattedNumber);
        if (!canSend) {
          const cooldownTime = this.rateLimiter.getCooldownTime(formattedNumber);
          throw new Error(`Rate limit reached. Please wait ${Math.ceil(cooldownTime! / 60000)} minutes before sending to ${to}`);
        }
      }

      // Send all messages in sequence
      for (const message of messages) {
        await this.client.sendMessage(formattedNumber, message);
      }
    } catch (error) {
      console.error('Failed to send message:', error);
      throw error;
    }
  }

  public async sendMediaMessage(to: string, mediaUrl: string, caption?: string): Promise<void> {
    if (!this.isReady) {
      throw new Error('WhatsApp client is not ready');
    }

    try {
      const formattedNumber = this.formatPhoneNumber(to);
      
      // Check rate limit before sending (counts as 2 messages if there's a caption)
      const messageCount = caption ? 2 : 1;
      for (let i = 0; i < messageCount; i++) {
        const canSend = await this.rateLimiter.canSendMessage(formattedNumber);
        if (!canSend) {
          const cooldownTime = this.rateLimiter.getCooldownTime(formattedNumber);
          throw new Error(`Rate limit reached. Please wait ${Math.ceil(cooldownTime! / 60000)} minutes before sending to ${to}`);
        }
      }

      const media = await this.client.sendMessage(formattedNumber, mediaUrl);
      if (caption) {
        await this.client.sendMessage(formattedNumber, caption);
      }
    } catch (error) {
      console.error('Failed to send media message:', error);
      throw error;
    }
  }

  private formatPhoneNumber(phone: string): string {
    // Remove any non-numeric characters
    const cleaned = phone.replace(/\D/g, '');
    // Ensure number has country code and WhatsApp suffix
    return cleaned.startsWith('1') ? `${cleaned}@c.us` : `1${cleaned}@c.us`;
  }



  public async getChats() {
    if (!this.isReady) {
      throw new Error('WhatsApp client is not ready');
    }
    return await this.client.getChats();
  }

  public isConnected(): boolean {
    return this.isReady;
  }

  public getQRCode(): string | null {
    return this.currentQRCode;
  }
}

```

# backend/src/shared

This is a binary file of the type: Binary

# backend/src/websocket/WebSocketManager.ts

```ts
import * as WebSocket from 'ws';
import { Server } from 'http';
import { EventEmitter } from 'events';
import { WSEventType } from '@shared/types/websocket';

export class WebSocketManager extends EventEmitter {
  private wss: WebSocket.Server;
  private clients: Set<WebSocket> = new Set();

  constructor(server: Server) {
    super();
    this.wss = new WebSocket.Server({ server });
    this.setupWebSocket();
  }

  private setupWebSocket() {
    this.wss.on('connection', (ws: WebSocket) => {
      this.clients.add(ws);

      ws.on('message', (message: string) => {
        try {
          const parsed = JSON.parse(message);
          this.emit('message', parsed);
        } catch (error) {
          console.error('Failed to parse WebSocket message:', error);
        }
      });

      ws.on('close', () => {
        this.clients.delete(ws);
      });

      // Send initial connection success
      ws.send(JSON.stringify({ type: 'connection:established', data: { timestamp: new Date() } }));
    });
  }

  public broadcast(type: WSEventType, data: any) {
    const message = JSON.stringify({ type, data });
    this.clients.forEach(client => {
      if (client.readyState === WebSocket.OPEN) {
        client.send(message);
      }
    });
  }

  public sendTo(client: WebSocket, type: WSEventType, data: any) {
    if (client.readyState === WebSocket.OPEN) {
      client.send(JSON.stringify({ type, data }));
    }
  }

  public getConnectedClients(): number {
    return this.clients.size;
  }
}

```

# backend/tsconfig.json

```json
  {
    "compilerOptions": {
      "target": "ES2020",
      "module": "commonjs",
      "lib": ["es2020"],
      "strict": true,
      "esModuleInterop": true,
      "skipLibCheck": true,
      "forceConsistentCasingInFileNames": true,
      "outDir": "dist",
      "rootDir": "src",
      "experimentalDecorators": true,
      "emitDecoratorMetadata": true,
      "strictPropertyInitialization": false,
      "baseUrl": ".",
      "paths": {
        "@shared/*": ["./src/shared/*"]
      },
    },
    "include": ["src/**/*"],
    "exclude": ["node_modules", "dist"]
  }

```

# docs/1- Project Overview.md

```md
**Title: WhatsApp Ads Software - Project Overview**

#### Purpose
This document provides a high-level summary of the WhatsApp Ads Software project, outlining its goals and core components.

#### Content
The WhatsApp Ads Software is a tool designed to send advertisements via WhatsApp to contacts, groups, and non-contacts. It includes a moderation panel for managing ad campaigns, controlling their execution, and monitoring their status. The system comprises:
- A **backend**: Web-based Express app built with "express-zod-api".
- A **frontend**: Client-Side Rendered (CSR) Next.js app, written exclusively in TypeScript (no JavaScript).
- **Real-time updates**: Achieved through persistent WebSocket connections.
- **WhatsApp integration**: Powered by whatsapp-web.js for sending ads.

The software aims to streamline WhatsApp-based advertising with features like audience selection, message templates, and moderation controls, all stored persistently in an SQLite database.

#### Key Objectives
- Enable efficient ad delivery via WhatsApp.
- Provide real-time status updates and moderation capabilities.
- Ensure scalability and type safety with modern technologies.
```

# docs/2- Technology Stack.md

```md
**Title: WhatsApp Ads Software - Technology Stack**

#### Purpose
This document details the technologies used in the WhatsApp Ads Software project, explaining their roles.

#### Content
The project leverages the following technologies:
- **Backend**: 
  - Framework: Express with "express-zod-api".
  - Purpose: Handles API endpoints, WebSocket connections, and integrates with whatsapp-web.js for ad sending.
- **Frontend**: 
  - Framework: Next.js (CSR mode).
  - Language: TypeScript only (no JavaScript allowed).
  - Purpose: Provides the user interface for ad creation, audience selection, and moderation.
- **Database**: 
  - Type: SQLite.
  - Purpose: Persistent storage for contacts, groups, phone book entries, ad campaigns, templates, and moderation logs.
- **WebSocket**: 
  - Type: Persistent connection between frontend and backend.
  - Purpose: Ensures real-time updates (e.g., connection status, QR code display, ad job progress).
- **WhatsApp Integration**: 
  - Library: whatsapp-web.js.
  - Purpose: Facilitates sending ads to WhatsApp contacts, groups, and non-contacts.

This stack ensures type safety, real-time functionality, and seamless WhatsApp automation.

```

# docs/3-Core Features.md

```md
**Title: WhatsApp Ads Software - Core Features**

#### Purpose
This document outlines the primary features of the WhatsApp Ads Software, focusing on functionality.

#### Content
1. **WhatsApp Ad Sending System**
   - Targets: Contacts, joined groups, non-contacts (via Phone Book).
   - Supported Content: Text messages, images, videos, multiple messages per campaign.
   - UI: Chatbox-style preview for creating message templates.

2. **Persistent WebSocket Connection**
   - Displays client connection status in real-time.
   - Shows QR Code for WhatsApp Web authentication (initial login or re-authentication).
   - Provides live updates for ad job progress.

3. **Moderation Panel (Web-Based)**
   - Features:
     - Approve or reject ad campaigns.
     - Start or stop active ad jobs.
     - Monitor sent messages and delivery status.

4. **Audience Management**
   - **Contacts & Groups**: Fetch and display WhatsApp contacts and joined groups; allow selection for campaigns.
   - **Phone Book**: Store non-contact phone numbers, create custom groups, and select for ad sending.

5. **Storage & Persistence**
   - Uses SQLite to store:
     - Contacts and groups.
     - Phone book entries.
     - Ad campaigns, message templates, and moderation status.

These features enable flexible ad creation, audience targeting, and administrative control.
```

# docs/4-System Architecture.md

```md
**Title: WhatsApp Ads Software - System Architecture**

#### Purpose
This document describes the architecture of the WhatsApp Ads Software, detailing backend and frontend responsibilities.

#### Content
- **Backend (Express with express-zod-api)**
  - Responsibilities:
    - API endpoints for fetching contacts/groups, managing phone book, ad jobs, and moderation tasks.
    - Maintains WebSocket connection with the frontend.
    - Integrates whatsapp-web.js for sending ads.
    - Uses SQLite for data persistence.
  - Key Interactions: Receives frontend requests, processes them, and communicates with WhatsApp.

- **Frontend (Next.js - CSR with TypeScript)**
  - Responsibilities:
    - Displays UI for WhatsApp authentication (QR Code on login).
    - Provides chatbox-style message template creation.
    - Allows audience selection (contacts, groups, phone book).
    - Hosts moderation panel (approve, start/stop jobs).
  - Key Interactions: Connects to backend via WebSocket for real-time updates and API calls for data.

The architecture ensures a clear separation of concerns, with the backend handling logic and the frontend focusing on user interaction.
```

# docs/5-Database Schema.md

```md
**Title: WhatsApp Ads Software - Database Schema**

#### Purpose
This document defines the SQLite database schema used for persistent storage.

#### Content
1. **Users**
   - Columns: `id (INTEGER, PK)`, `name (TEXT)`, `phone (TEXT)`, `session (TEXT)`.
   - Purpose: Stores user data and WhatsApp session info.

2. **Contacts & Groups**
   - Columns: `id (INTEGER, PK)`, `name (TEXT)`, `phone (TEXT)`, `group_id (TEXT)`.
   - Purpose: Tracks WhatsApp contacts and groups.

3. **Phone Book**
   - Columns: `id (INTEGER, PK)`, `name (TEXT)`, `phone (TEXT)`, `group_name (TEXT)`.
   - Purpose: Manages non-contact phone numbers and custom groups.

4. **Message Templates**
   - Columns: `id (INTEGER, PK)`, `title (TEXT)`, `content (TEXT, JSON)`.
   - Purpose: Stores reusable ad message templates.

5. **Ad Jobs**
   - Columns: `id (INTEGER, PK)`, `user_id (INTEGER)`, `template_id (INTEGER)`, `status (TEXT)`, `audience (TEXT, JSON)`.
   - Purpose: Tracks ad campaigns, their status, and target audience.

6. **Moderation Logs**
   - Columns: `id (INTEGER, PK)`, `job_id (INTEGER)`, `moderator (TEXT)`, `action (TEXT)`.
   - Purpose: Logs moderation actions for auditing.

This schema supports all core features with relational integrity.
```

# docs/6-Workflow.md

```md
**Title: WhatsApp Ads Software - Workflow**

#### Purpose
This document explains the operational workflow of the WhatsApp Ads Software.

#### Content
1. **Authentication & Connection**
   - User logs in.
   - WebSocket connection is established.
   - If no session exists, QR Code is displayed for WhatsApp login.
   - WebSocket tracks connection status.

2. **Creating an Ad Campaign**
   - User selects audience (contacts, groups, phone book).
   - User picks or creates a message template.
   - Submits campaign for moderation.
   - Admin approves or rejects.

3. **Sending Ads**
   - Approved jobs start.
   - whatsapp-web.js sends messages.
   - WebSocket updates frontend with progress.

4. **Moderation**
   - Admin reviews pending jobs.
   - Approves or rejects them.
   - Approved jobs proceed; rejected ones are archived.

This workflow ensures a smooth process from login to ad delivery.
```

# docs/7-Security Considerations.md

```md
**Title: WhatsApp Ads Software - Security Considerations**

#### Purpose
This document highlights security measures to protect the system and its data.

#### Content
- **WhatsApp Session Management**: Store sessions securely to avoid frequent logins.
- **Data Privacy**: Encrypt SQLite database or restrict access.
- **Rate Limiting**: Limit ad sending rates to avoid WhatsApp bans.
- **WebSocket Security**: Authenticate users before establishing connections.

These measures safeguard user data and maintain system reliability.
```

# docs/8-Future Enhancements.md

```md
**Title: WhatsApp Ads Software - Future Enhancements**

#### Purpose
This document lists potential improvements for the WhatsApp Ads Software.

#### Content
- Support multiple WhatsApp accounts per user.
- Add an analytics dashboard for ad performance tracking.
- Implement scheduling for automated ad sending.
- Integrate AI for message optimization.

These enhancements aim to improve scalability and user experience.
```

# docs/9-Conclusion.md

```md
**Title: WhatsApp Ads Software - Conclusion**

#### Purpose
This document summarizes the project’s value and capabilities.

#### Content
The WhatsApp Ads Software provides an efficient solution for WhatsApp-based advertising. With real-time moderation, audience selection, and message template management, it leverages TypeScript, Express, and Next.js for scalability and security. Integration with whatsapp-web.js ensures seamless WhatsApp automation, making it a robust tool for targeted ad campaigns.
```

# frontend/.gitignore

```
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts

```

# frontend/components.json

```json
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "tailwind.config.js",
    "css": "src/app/globals.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "iconLibrary": "lucide"
}
```

# frontend/eslint.config.mjs

```mjs
import { dirname } from "path";
import { fileURLToPath } from "url";
import { FlatCompat } from "@eslint/eslintrc";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const compat = new FlatCompat({
  baseDirectory: __dirname,
});

const eslintConfig = [
  ...compat.extends("next/core-web-vitals", "next/typescript"),
];

export default eslintConfig;

```

# frontend/next-env.d.ts

```ts
/// <reference types="next" />
/// <reference types="next/image-types/global" />

// NOTE: This file should not be edited
// see https://nextjs.org/docs/basic-features/typescript for more information.

```

# frontend/next.config.js

```js
/** @type {import('next').NextConfig} */
const nextConfig = {
  reactStrictMode: true,
  swcMinify: true,
  env: {
    NEXT_PUBLIC_API_URL: process.env.NEXT_PUBLIC_API_URL || 'http://localhost:8000',
    NEXT_PUBLIC_WS_URL: process.env.NEXT_PUBLIC_WS_URL || 'ws://localhost:8000',
  },
};

module.exports = nextConfig;

```

# frontend/package.json

```json
{
  "name": "whatsapp-ads-frontend",
  "version": "1.0.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "type-check": "tsc --noEmit"
  },
  "dependencies": {
    "@headlessui/react": "^1.7.19",
    "@heroicons/react": "^2.2.0",
    "@radix-ui/react-avatar": "^1.1.3",
    "@radix-ui/react-dialog": "^1.1.6",
    "@radix-ui/react-slot": "^1.1.2",
    "@radix-ui/react-tabs": "^1.1.3",
    "@tanstack/react-query": "^5.67.3",
    "axios": "^1.8.2",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "date-fns": "^3.6.0",
    "lucide-react": "^0.479.0",
    "next": "^14.0.4",
    "qrcode.react": "^4.2.0",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-hook-form": "^7.54.2",
    "recharts": "^2.15.1",
    "tailwind-merge": "^2.6.0",
    "tailwindcss-animate": "^1.0.7",
    "zod": "^3.24.2",
    "zustand": "^4.5.6"
  },
  "devDependencies": {
    "@tailwindcss/forms": "^0.5.7",
    "@types/node": "^20.17.24",
    "@types/react": "^18.3.18",
    "@types/react-dom": "^18.3.5",
    "@typescript-eslint/eslint-plugin": "^6.21.0",
    "@typescript-eslint/parser": "^6.21.0",
    "autoprefixer": "^10.4.21",
    "eslint": "^8.56.0",
    "eslint-config-next": "14.0.4",
    "eslint-config-prettier": "^9.1.0",
    "postcss": "^8.5.3",
    "prettier": "^3.1.1",
    "tailwindcss": "^3.4.17",
    "typescript": "^5.8.2"
  }
}

```

# frontend/postcss.config.js

```js
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}

```

# frontend/postcss.config.mjs

```mjs
const config = {
  plugins: ["@tailwindcss/postcss"],
};

export default config;

```

# frontend/public/file.svg

This is a file of the type: SVG Image

# frontend/public/globe.svg

This is a file of the type: SVG Image

# frontend/public/next.svg

This is a file of the type: SVG Image

# frontend/public/vercel.svg

This is a file of the type: SVG Image

# frontend/public/window.svg

This is a file of the type: SVG Image

# frontend/README.md

```md
This is a [Next.js](https://nextjs.org) project bootstrapped with [`create-next-app`](https://nextjs.org/docs/app/api-reference/cli/create-next-app).

## Getting Started

First, run the development server:

\`\`\`bash
npm run dev
# or
yarn dev
# or
pnpm dev
# or
bun dev
\`\`\`

Open [http://localhost:3000](http://localhost:3000) with your browser to see the result.

You can start editing the page by modifying `app/page.tsx`. The page auto-updates as you edit the file.

This project uses [`next/font`](https://nextjs.org/docs/app/building-your-application/optimizing/fonts) to automatically optimize and load [Geist](https://vercel.com/font), a new font family for Vercel.

## Learn More

To learn more about Next.js, take a look at the following resources:

- [Next.js Documentation](https://nextjs.org/docs) - learn about Next.js features and API.
- [Learn Next.js](https://nextjs.org/learn) - an interactive Next.js tutorial.

You can check out [the Next.js GitHub repository](https://github.com/vercel/next.js) - your feedback and contributions are welcome!

## Deploy on Vercel

The easiest way to deploy your Next.js app is to use the [Vercel Platform](https://vercel.com/new?utm_medium=default-template&filter=next.js&utm_source=create-next-app&utm_campaign=create-next-app-readme) from the creators of Next.js.

Check out our [Next.js deployment documentation](https://nextjs.org/docs/app/building-your-application/deploying) for more details.

```

# frontend/src/app/ads/create/page.tsx

```tsx
'use client';

import { useState } from 'react';
import { useRouter } from 'next/navigation';
import { useQuery, useMutation } from '@tanstack/react-query';
import { MessageTemplateEditor } from '@/components/MessageTemplateEditor';
import { AdScheduler } from '@/components/AdScheduler';
import { AudienceSelector } from '@/components/AudienceSelector';
import { whatsappApi, templateApi, adJobApi } from '@/services/api';
import { useWebSocket } from '@/hooks/useWebSocket';

export default function CreateAdPage() {
  const router = useRouter();
  const { status: wsStatus } = useWebSocket();
  const [step, setStep] = useState<'template' | 'audience' | 'schedule'>('template');
  const [template, setTemplate] = useState<{
    title: string;
    messages: Array<{ type: 'text' | 'media'; content: string; caption?: string }>;
  } | null>(null);

  // Fetch data for audience selection
  const { data: contactGroups } = useQuery({
    queryKey: ['contacts'],
    queryFn: async () => {
      const response = await whatsappApi.getContacts();
      return response.data;
    },
  });

  // Transform ContactGroups into separate contacts and groups
  const contacts = contactGroups?.filter(cg => cg.type === 'contact').map(cg => ({
    id: cg.id,
    name: cg.name,
    phone: cg.phone || '',
  }));

  const groups = contactGroups?.filter(cg => cg.type === 'group').map(cg => ({
    id: cg.id,
    name: cg.name,
    groupId: cg.groupId || '',
  }));

  const { data: phoneBookEntries } = useQuery({
    queryKey: ['phonebook'],
    queryFn: async () => {
      const response = await phoneBookApi.getEntries();
      return response.data;
    },
  });

  const { data: templates } = useQuery({
    queryKey: ['phonebook'],
    queryFn: async () => {
      const response = await whatsappApi.getContacts();
      return response.data;
    },
  });

  // Create template mutation
  const createTemplateMutation = useMutation({
    mutationFn: async (templateData: any) => {
      const response = await templateApi.createTemplate(templateData);
      return response.data;
    },
  });

  // Create ad job mutation
  const createJobMutation = useMutation({
    mutationFn: async (jobData: any) => {
      const response = await adJobApi.createJob(jobData);
      return response.data;
    },
    onSuccess: () => {
      router.push('/ads');
    },
  });

  const handleTemplateCreation = async (title: string, messages: any[]) => {
    setTemplate({ title, messages });
    setStep('audience');

    // Create template in background
    await createTemplateMutation.mutateAsync({
      title,
      content: JSON.stringify(messages),
    });
  };

  const [selectedAudience, setSelectedAudience] = useState<{
    contacts: any[];
    groups: any[];
    phoneBook: any[];
  } | null>(null);

  const handleAudienceSelection = async (audience: {
    contacts: any[];
    groups: any[];
    phoneBook: any[];
  }) => {
    setSelectedAudience(audience);
    setStep('schedule');
  };

  const handleScheduleSubmit = async (schedule: any) => {
    if (!template || !selectedAudience) return;

    // Create ad job
    await createJobMutation.mutateAsync({
      templateId: createTemplateMutation.data?.id,
      audience: JSON.stringify(selectedAudience),
      schedule,
    });
  };

  if (!wsStatus.isConnected) {
    return (
      <div className="max-w-7xl mx-auto py-6 sm:px-6 lg:px-8">
        <div className="bg-yellow-50 p-4 rounded-md">
          <div className="flex">
            <div className="flex-shrink-0">
              <svg
                className="h-5 w-5 text-yellow-400"
                viewBox="0 0 20 20"
                fill="currentColor"
              >
                <path
                  fillRule="evenodd"
                  d="M8.485 2.495c.673-1.167 2.357-1.167 3.03 0l6.28 10.875c.673 1.167-.17 2.625-1.516 2.625H3.72c-1.347 0-2.189-1.458-1.515-2.625L8.485 2.495zM10 5a.75.75 0 01.75.75v3.5a.75.75 0 01-1.5 0v-3.5A.75.75 0 0110 5zm0 9a1 1 0 100-2 1 1 0 000 2z"
                  clipRule="evenodd"
                />
              </svg>
            </div>
            <div className="ml-3">
              <h3 className="text-sm font-medium text-yellow-800">
                WhatsApp Connection Required
              </h3>
              <p className="mt-2 text-sm text-yellow-700">
                Please ensure WhatsApp is connected before creating an ad campaign.
              </p>
            </div>
          </div>
        </div>
      </div>
    );
  }

  return (
    <div className="max-w-7xl mx-auto py-6 sm:px-6 lg:px-8">
      <div className="md:flex md:items-center md:justify-between">
        <div className="min-w-0 flex-1">
          <h2 className="text-2xl font-bold leading-7 text-gray-900 sm:truncate sm:text-3xl sm:tracking-tight">
            Create New Ad Campaign
          </h2>
        </div>
      </div>

      <div className="mt-8 space-y-8">
        {/* Step indicator */}
        <nav aria-label="Progress">
          <ol role="list" className="space-y-4 md:flex md:space-y-0 md:space-x-8">
            <li className="md:flex-1">
              <button
                onClick={() => setStep('template')}
                className={`group ${
                  step === 'template'
                    ? 'border-indigo-600'
                    : 'border-gray-200 hover:border-gray-300'
                } flex w-full items-center border-l-4 py-2 pl-4 text-left text-sm font-medium`}
              >
                <span
                  className={`${
                    step === 'template' ? 'text-indigo-600' : 'text-gray-500'
                  } flex h-10 w-10 flex-shrink-0 items-center justify-center rounded-full border-2 ${
                    step === 'template'
                      ? 'border-indigo-600'
                      : 'border-gray-300 group-hover:border-gray-400'
                  }`}
                >
                  1
                </span>
                <span className="ml-4 text-sm font-medium">
                  Create Message Template
                </span>
              </button>
            </li>

            <li className="md:flex-1">
              <button
                onClick={() => template && setStep('audience')}
                className={`group ${
                  step === 'audience'
                    ? 'border-indigo-600'
                    : 'border-gray-200 hover:border-gray-300'
                } flex w-full items-center border-l-4 py-2 pl-4 text-left text-sm font-medium ${
                  !template && 'opacity-50 cursor-not-allowed'
                }`}
                disabled={!template}
              >
                <span
                  className={`${
                    step === 'audience' ? 'text-indigo-600' : 'text-gray-500'
                  } flex h-10 w-10 flex-shrink-0 items-center justify-center rounded-full border-2 ${
                    step === 'audience'
                      ? 'border-indigo-600'
                      : 'border-gray-300 group-hover:border-gray-400'
                  }`}
                >
                  2
                </span>
                <span className="ml-4 text-sm font-medium">Select Audience</span>
              </button>
            </li>

            <li className="md:flex-1">
              <button
                onClick={() => selectedAudience && setStep('schedule')}
                className={`group ${
                  step === 'schedule'
                    ? 'border-indigo-600'
                    : 'border-gray-200 hover:border-gray-300'
                } flex w-full items-center border-l-4 py-2 pl-4 text-left text-sm font-medium ${
                  !selectedAudience && 'opacity-50 cursor-not-allowed'
                }`}
                disabled={!selectedAudience}
              >
                <span
                  className={`${
                    step === 'schedule' ? 'text-indigo-600' : 'text-gray-500'
                  } flex h-10 w-10 flex-shrink-0 items-center justify-center rounded-full border-2 ${
                    step === 'schedule'
                      ? 'border-indigo-600'
                      : 'border-gray-300 group-hover:border-gray-400'
                  }`}
                >
                  3
                </span>
                <span className="ml-4 text-sm font-medium">Schedule Campaign</span>
              </button>
            </li>
          </ol>
        </nav>

        {/* Step content */}
        <div className="mt-8">
          {step === 'template' && (
            <MessageTemplateEditor onSave={handleTemplateCreation} />
          )}

          {step === 'audience' && contacts && groups && phoneBookEntries && (
            <AudienceSelector
              contacts={contacts || []}
              groups={groups || []}
              phoneBook={phoneBookEntries || []}
              onSelectionChange={handleAudienceSelection}
            />
          )}

          {step === 'schedule' && createJobMutation.data && (
            <AdScheduler
              jobId={createJobMutation.data.id}
              onScheduleSubmit={handleScheduleSubmit}
            />
          )}
        </div>
      </div>
    </div>
  );
}

```

# frontend/src/app/analytics/page.tsx

```tsx
'use client';

import { AnalyticsDashboard } from '@/components/AnalyticsDashboard';
import { useWebSocket } from '@/hooks/useWebSocket';

export default function AnalyticsPage() {
  const { status: wsStatus } = useWebSocket();

  return (
    <div className="max-w-7xl mx-auto py-6 sm:px-6 lg:px-8">
      <div className="md:flex md:items-center md:justify-between">
        <div className="min-w-0 flex-1">
          <h2 className="text-2xl font-bold leading-7 text-gray-900 sm:truncate sm:text-3xl sm:tracking-tight">
            Analytics Dashboard
          </h2>
          <p className="mt-1 text-sm text-gray-500">
            Track your WhatsApp ad campaign performance
          </p>
        </div>
        <div className="mt-4 flex md:ml-4 md:mt-0">
          <div className="flex items-center gap-2">
            <span
              className={`inline-block h-3 w-3 rounded-full ${
                wsStatus.isConnected ? 'bg-green-500' : 'bg-red-500'
              }`}
            />
            <span className="text-sm text-gray-600">
              {wsStatus.isConnected ? 'Connected' : 'Disconnected'}
            </span>
          </div>
        </div>
      </div>

      <div className="mt-8">
        <AnalyticsDashboard />
      </div>
    </div>
  );
}

```

# frontend/src/app/contacts/page.tsx

```tsx
'use client';

import { useState } from 'react';
import { Input } from '@/components/ui/input';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { ContactList } from '@/components/contacts/ContactList';
import { GroupList } from '@/components/contacts/GroupList';
import { Button } from '@/components/ui/button';
import { PlusIcon, SearchIcon } from 'lucide-react';
import { ContactFilter, GroupFilter } from '@shared/types/contacts';

export default function ContactsPage() {
  const [contactFilter, setContactFilter] = useState<ContactFilter>({
    search: '',
    isMyContact: undefined,
    page: 1,
    pageSize: 20,
  });

  const [groupFilter, setGroupFilter] = useState<GroupFilter>({
    search: '',
    isAdmin: undefined,
    page: 1,
    pageSize: 20,
  });

  return (
    <div className="container mx-auto py-6 space-y-6">
      <div className="flex justify-between items-center">
        <h1 className="text-2xl font-bold">Contacts & Groups</h1>
        <Button>
          <PlusIcon className="w-4 h-4 mr-2" />
          Import Contacts
        </Button>
      </div>

      <Tabs defaultValue="contacts" className="w-full">
        <TabsList className="grid w-full grid-cols-2">
          <TabsTrigger value="contacts">Contacts</TabsTrigger>
          <TabsTrigger value="groups">Groups</TabsTrigger>
        </TabsList>

        <TabsContent value="contacts" className="space-y-4">
          <div className="flex gap-4">
            <div className="relative flex-1">
              <SearchIcon className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-500 w-4 h-4" />
              <Input
                placeholder="Search contacts..."
                className="pl-10"
                value={contactFilter.search}
                onChange={(e) => setContactFilter({ ...contactFilter, search: e.target.value })}
              />
            </div>
            <Button variant="outline" onClick={() => setContactFilter({ ...contactFilter, isMyContact: !contactFilter.isMyContact })}>
              {contactFilter.isMyContact ? 'All Contacts' : 'My Contacts'}
            </Button>
          </div>
          <ContactList filter={contactFilter} onPageChange={(page) => setContactFilter({ ...contactFilter, page })} />
        </TabsContent>

        <TabsContent value="groups" className="space-y-4">
          <div className="flex gap-4">
            <div className="relative flex-1">
              <SearchIcon className="absolute left-3 top-1/2 transform -translate-y-1/2 text-gray-500 w-4 h-4" />
              <Input
                placeholder="Search groups..."
                className="pl-10"
                value={groupFilter.search}
                onChange={(e) => setGroupFilter({ ...groupFilter, search: e.target.value })}
              />
            </div>
            <Button variant="outline" onClick={() => setGroupFilter({ ...groupFilter, isAdmin: !groupFilter.isAdmin })}>
              {groupFilter.isAdmin ? 'All Groups' : 'Admin Only'}
            </Button>
          </div>
          <GroupList filter={groupFilter} onPageChange={(page) => setGroupFilter({ ...groupFilter, page })} />
        </TabsContent>
      </Tabs>
    </div>
  );
}

```

# frontend/src/app/favicon.ico

This is a binary file of the type: Binary

# frontend/src/app/globals.css

```css
@tailwind base;
@tailwind components;
@tailwind utilities;

body {
  font-family: var(--font-sans), ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
}



@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 0 0% 3.9%;
    --card: 0 0% 100%;
    --card-foreground: 0 0% 3.9%;
    --popover: 0 0% 100%;
    --popover-foreground: 0 0% 3.9%;
    --primary: 0 0% 9%;
    --primary-foreground: 0 0% 98%;
    --secondary: 0 0% 96.1%;
    --secondary-foreground: 0 0% 9%;
    --muted: 0 0% 96.1%;
    --muted-foreground: 0 0% 45.1%;
    --accent: 0 0% 96.1%;
    --accent-foreground: 0 0% 9%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 0 0% 98%;
    --border: 0 0% 89.8%;
    --input: 0 0% 89.8%;
    --ring: 0 0% 3.9%;
    --chart-1: 12 76% 61%;
    --chart-2: 173 58% 39%;
    --chart-3: 197 37% 24%;
    --chart-4: 43 74% 66%;
    --chart-5: 27 87% 67%;
    --radius: 0.5rem;
  }
  .dark {
    --background: 0 0% 3.9%;
    --foreground: 0 0% 98%;
    --card: 0 0% 3.9%;
    --card-foreground: 0 0% 98%;
    --popover: 0 0% 3.9%;
    --popover-foreground: 0 0% 98%;
    --primary: 0 0% 98%;
    --primary-foreground: 0 0% 9%;
    --secondary: 0 0% 14.9%;
    --secondary-foreground: 0 0% 98%;
    --muted: 0 0% 14.9%;
    --muted-foreground: 0 0% 63.9%;
    --accent: 0 0% 14.9%;
    --accent-foreground: 0 0% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 0 0% 98%;
    --border: 0 0% 14.9%;
    --input: 0 0% 14.9%;
    --ring: 0 0% 83.1%;
    --chart-1: 220 70% 50%;
    --chart-2: 160 60% 45%;
    --chart-3: 30 80% 55%;
    --chart-4: 280 65% 60%;
    --chart-5: 340 75% 55%;
  }
}



@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}

```

# frontend/src/app/layout.tsx

```tsx
import type { Metadata } from "next";
import { Inter } from "next/font/google";
import "./globals.css";
import { Providers } from "@/app/providers";

const inter = Inter({
  subsets: ["latin"],
  variable: "--font-inter",
});

export const metadata: Metadata = {
  title: "WhatsApp Ads Software",
  description: "Professional WhatsApp advertising platform for managing and sending ads to contacts, groups, and non-contacts.",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en" className={inter.variable}>
      <body className="h-full bg-gray-50">
        <Providers>{children}</Providers>
      </body>
    </html>
  );
}

```

# frontend/src/app/moderation/page.tsx

```tsx
'use client';

import { ModerationPanel } from '@/components/ModerationPanel';
import { useWebSocket } from '@/hooks/useWebSocket';

export default function ModerationPage() {
  const { status: wsStatus } = useWebSocket();

  return (
    <div className="max-w-7xl mx-auto py-6 sm:px-6 lg:px-8">
      <div className="md:flex md:items-center md:justify-between">
        <div className="min-w-0 flex-1">
          <h2 className="text-2xl font-bold leading-7 text-gray-900 sm:truncate sm:text-3xl sm:tracking-tight">
            Moderation Panel
          </h2>
          <p className="mt-1 text-sm text-gray-500">
            Review and manage ad campaigns
          </p>
        </div>
        <div className="mt-4 flex md:ml-4 md:mt-0">
          <div className="flex items-center gap-2">
            <span
              className={`inline-block h-3 w-3 rounded-full ${
                wsStatus.isConnected ? 'bg-green-500' : 'bg-red-500'
              }`}
            />
            <span className="text-sm text-gray-600">
              {wsStatus.isConnected ? 'Connected' : 'Disconnected'}
            </span>
          </div>
        </div>
      </div>

      <div className="mt-8">
        <ModerationPanel />
      </div>
    </div>
  );
}

```

# frontend/src/app/page.tsx

```tsx
'use client';

import { useQuery } from '@tanstack/react-query';
import { useWebSocket } from '@/hooks/useWebSocket';
import { adJobApi, moderationApi } from '@/services/api';
import { WhatsAppQRCode } from '@/components/WhatsAppQRCode';
import {
  CheckCircleIcon,
  ExclamationCircleIcon,
  ClockIcon,
} from '@heroicons/react/24/outline';
import { format } from 'date-fns';

export default function Dashboard() {
  const { status: wsStatus } = useWebSocket();

  // Debug logging for WhatsApp connection status
  console.log('[Dashboard] WhatsApp status:', {
    isConnected: wsStatus.isConnected,
    hasQRCode: Boolean(wsStatus.qrCode),
    qrCodeLength: wsStatus.qrCode?.length
  });
  
  const { data: pendingJobs } = useQuery({
    queryKey: ['pending-jobs'],
    queryFn: async () => {
      const response = await moderationApi.getModerationQueue();
      return response.data;
    },
  });

  const { data: recentJobs } = useQuery({
    queryKey: ['recent-jobs'],
    queryFn: async () => {
      const response = await adJobApi.getJobs();
      return response.data;
    },
  });

  return (
    <div className="space-y-6">
      {/* WhatsApp Connection Status */}
      <div className="bg-white shadow sm:rounded-lg">
        <div className="px-4 py-5 sm:p-6">
          <div className="sm:flex sm:items-start sm:justify-between">
            <div className="w-full">
              <h3 className="text-base font-semibold leading-6 text-gray-900">
                WhatsApp Connection Status
              </h3>
              <div className="mt-2">
                {/* Debug info */}
                {process.env.NODE_ENV === 'development' && (
                  <pre className="text-xs text-gray-500 mb-4">
                    {JSON.stringify({ wsStatus }, null, 2)}
                  </pre>
                )}

                {wsStatus.qrCode ? (
                  <div className="space-y-4">
                    <div className="flex items-center gap-2 text-sm text-gray-500">
                      <ClockIcon className="h-5 w-5 text-yellow-500" />
                      <span className="font-medium">WhatsApp authentication required</span>
                    </div>
                    <div className="flex flex-col items-center justify-center lg:flex-row lg:items-start lg:gap-8">
                      <WhatsAppQRCode 
                        qrCode={wsStatus.qrCode}
                        onRefresh={() => {
                          console.log('[Dashboard] QR code refresh requested');
                          // The client will automatically refresh when disconnected
                        }} 
                      />
                      <div className="mt-4 lg:mt-0 max-w-sm text-sm text-gray-500">
                        <h4 className="font-semibold mb-2">Having trouble?</h4>
                        <ul className="space-y-2 list-disc pl-4">
                          <li>Make sure you have the latest version of WhatsApp installed on your phone</li>
                          <li>Check your internet connection</li>
                          <li>Try refreshing the QR code if it expires</li>
                          <li>Make sure you're using the primary device with your WhatsApp account</li>
                        </ul>
                      </div>
                    </div>
                  </div>
                ) : wsStatus.isConnected ? (
                  <div className="max-w-xl text-sm text-gray-500">
                    <div className="flex items-center gap-2 mb-2">
                      <CheckCircleIcon className="h-5 w-5 text-green-500" />
                      <span className="font-medium">Connected and ready to send messages</span>
                    </div>
                    <p>Your WhatsApp account is connected and ready to use. You can now send messages and manage your campaigns.</p>
                  </div>
                ) : (
                  <div className="max-w-xl text-sm text-gray-500">
                    <div className="flex items-center gap-2 mb-2">
                      <ExclamationCircleIcon className="h-5 w-5 text-red-500" />
                      <span className="font-medium">Initializing WhatsApp connection</span>
                    </div>
                    <p>Please wait while we establish a connection to WhatsApp. This should only take a few moments...</p>
                  </div>
                )}
              </div>
            </div>
          </div>
        </div>
      </div>

      {/* Quick Stats */}
      <div className="grid grid-cols-1 gap-6 sm:grid-cols-2 lg:grid-cols-4">
        <div className="bg-white overflow-hidden shadow rounded-lg">
          <div className="p-5">
            <div className="flex items-center">
              <div className="flex-shrink-0">
                <ClockIcon className="h-6 w-6 text-gray-400" />
              </div>
              <div className="ml-5 w-0 flex-1">
                <dl>
                  <dt className="text-sm font-medium text-gray-500 truncate">
                    Pending Approval
                  </dt>
                  <dd className="text-lg font-medium text-gray-900">
                    {pendingJobs?.length || 0}
                  </dd>
                </dl>
              </div>
            </div>
          </div>
        </div>
      </div>

      {/* Recent Ad Jobs */}
      <div className="bg-white shadow sm:rounded-lg">
        <div className="px-4 py-5 sm:p-6">
          <h3 className="text-base font-semibold leading-6 text-gray-900">
            Recent Ad Jobs
          </h3>
          <div className="mt-4 flow-root">
            <div className="-mx-4 -my-2 overflow-x-auto sm:-mx-6 lg:-mx-8">
              <div className="inline-block min-w-full py-2 align-middle sm:px-6 lg:px-8">
                <table className="min-w-full divide-y divide-gray-300">
                  <thead>
                    <tr>
                      <th className="py-3.5 pl-4 pr-3 text-left text-sm font-semibold text-gray-900">
                        Template
                      </th>
                      <th className="px-3 py-3.5 text-left text-sm font-semibold text-gray-900">
                        Status
                      </th>
                      <th className="px-3 py-3.5 text-left text-sm font-semibold text-gray-900">
                        Progress
                      </th>
                      <th className="px-3 py-3.5 text-left text-sm font-semibold text-gray-900">
                        Created
                      </th>
                    </tr>
                  </thead>
                  <tbody className="divide-y divide-gray-200">
                    {recentJobs?.slice(0, 5).map((job) => (
                      <tr key={job.id}>
                        <td className="whitespace-nowrap py-4 pl-4 pr-3 text-sm font-medium text-gray-900">
                          Template #{job.templateId}
                        </td>
                        <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">
                          {job.status}
                        </td>
                        <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">
                          {job.messagesDelivered}/{job.messagesSent}
                        </td>
                        <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">
                          {format(new Date(job.createdAt), 'MMM d, yyyy')}
                        </td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
}

```

# frontend/src/app/providers.tsx

```tsx
'use client';

import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { useState } from 'react';
import MainLayout from '@/components/layout/MainLayout';

export function Providers({ children }: { children: React.ReactNode }) {
  const [queryClient] = useState(() => new QueryClient({
    defaultOptions: {
      queries: {
        staleTime: 5 * 1000, // 5 seconds
        retry: 1,
      },
    },
  }));

  return (
    <QueryClientProvider client={queryClient}>
      <MainLayout>{children}</MainLayout>
    </QueryClientProvider>
  );
}

```

# frontend/src/app/schedule/page.tsx

```tsx
'use client';

import { useState } from 'react';
import { useQuery } from '@tanstack/react-query';
import { adJobApi } from '@/services/api';
import { AdJob } from '@/types';
import { AdScheduler } from '@/components/AdScheduler';

export default function SchedulePage() {
  const [selectedJob, setSelectedJob] = useState<AdJob | null>(null);

  const { data: jobs } = useQuery({
    queryKey: ['scheduled-jobs'],
    queryFn: async () => {
      const response = await adJobApi.getJobs();
      return response.data.filter(job => job.status !== 'completed' && job.status !== 'failed');
    },
  });

  return (
    <div>
      <div className="md:flex md:items-center md:justify-between mb-8">
        <div className="min-w-0 flex-1">
          <h2 className="text-2xl font-bold leading-7 text-gray-900 sm:truncate sm:text-3xl sm:tracking-tight">
            Ad Campaign Schedule
          </h2>
          <p className="mt-1 text-sm text-gray-500">
            Schedule and manage your ad campaigns
          </p>
        </div>
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-2 gap-8">
        {/* Scheduled Jobs List */}
        <div className="bg-white shadow sm:rounded-lg">
          <div className="px-4 py-5 sm:p-6">
            <h3 className="text-base font-semibold leading-6 text-gray-900">
              Active Campaigns
            </h3>
            <div className="mt-6 flow-root">
              <ul role="list" className="-my-5 divide-y divide-gray-200">
                {jobs?.map((job) => (
                  <li
                    key={job.id}
                    className="py-4 cursor-pointer hover:bg-gray-50"
                    onClick={() => setSelectedJob(job)}
                  >
                    <div className="flex items-center space-x-4">
                      <div className="min-w-0 flex-1">
                        <p className="truncate text-sm font-medium text-gray-900">
                          Template #{job.templateId}
                        </p>
                        <p className="truncate text-sm text-gray-500">
                          Status: {job.status}
                        </p>
                      </div>
                      <div>
                        <span className="inline-flex items-center rounded-full bg-green-50 px-2 py-1 text-xs font-medium text-green-700 ring-1 ring-inset ring-green-600/20">
                          {job.messagesDelivered}/{job.messagesSent}
                        </span>
                      </div>
                    </div>
                  </li>
                ))}
              </ul>
            </div>
          </div>
        </div>

        {/* Scheduler */}
        <div className="bg-white shadow sm:rounded-lg">
          <div className="px-4 py-5 sm:p-6">
            {selectedJob ? (
              <AdScheduler
                jobId={selectedJob.id}
                onScheduleSubmit={async (schedule) => {
                  // Handle schedule update
                  await adJobApi.updateJobSchedule(selectedJob.id, schedule);
                  setSelectedJob(null);
                }}
              />
            ) : (
              <div className="text-center py-12">
                <p className="text-sm text-gray-500">
                  Select a campaign from the list to schedule
                </p>
              </div>
            )}
          </div>
        </div>
      </div>
    </div>
  );
}

```

# frontend/src/app/templates/page.tsx

```tsx
'use client';

import { useState } from 'react';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { templateApi } from '@/services/api';
import { MessageTemplate } from '@/types';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Textarea } from '@/components/ui/textarea';
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from '@/components/ui/dialog';
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from '@/components/ui/table';

// Using a simple toast function until we add a proper toast library
const toast = {
  success: (message: string) => console.log('Success:', message),
  error: (message: string) => console.error('Error:', message)
};

export default function TemplatesPage() {
  const queryClient = useQueryClient();
  const [isCreateOpen, setIsCreateOpen] = useState(false);
  const [isUpdateOpen, setIsUpdateOpen] = useState(false);
  const [newTemplate, setNewTemplate] = useState({ title: '', messages: [''] });
  const [selectedTemplate, setSelectedTemplate] = useState<MessageTemplate | null>(null);

  const { data: templates, isLoading } = useQuery<{items: MessageTemplate[]}, Error>({
    queryKey: ['templates'],
    queryFn: async () => {
      const response = await templateApi.getTemplates();
      return (response.data as any).data;
    },
  });

  const updateMutation = useMutation<MessageTemplate, Error, { id: number, template: Omit<MessageTemplate, 'id' | 'createdAt' | 'updatedAt'> }>({    mutationFn: async ({ id, template }) => {
      const response = await templateApi.updateTemplate(id, template);
      return response.data;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['templates'] });
      setIsUpdateOpen(false);
      setSelectedTemplate(null);
      toast.success('Template updated successfully');
    },
    onError: () => {
      toast.error('Failed to update template');
    },
  });

  const createMutation = useMutation<MessageTemplate, Error, Omit<MessageTemplate, 'id' | 'createdAt' | 'updatedAt'>>({
    mutationFn: async (data) => {
      const response = await templateApi.createTemplate(data);
      return response.data;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['templates'] });
      setIsCreateOpen(false);
      setNewTemplate({ title: '', messages: [''] });
      toast.success('Template created successfully');
    },
    onError: () => {
      toast.error('Failed to create template');
    },
  });

  const deleteMutation = useMutation<void, Error, number>({
    mutationFn: async (id) => {
      await templateApi.deleteTemplate(id);
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['templates'] });
      toast.success('Template deleted successfully');
    },
    onError: () => {
      toast.error('Failed to delete template');
    },
  });

  const handleCreate = () => {
    if (!newTemplate.title || !newTemplate.messages[0]) {
      toast.error('Please fill in all fields');
      return;
    }
    createMutation.mutate(newTemplate);
  };

  const handleDelete = (id: number) => {
    if (window.confirm('Are you sure you want to delete this template?')) {
      deleteMutation.mutate(id);
    }
  };

  if (isLoading) {
    return <div className="p-8">Loading...</div>;
  }

  return (
    <div className="p-8">
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-2xl font-bold">Message Templates</h1>
        <Dialog open={isCreateOpen} onOpenChange={setIsCreateOpen}>
          <DialogTrigger asChild>
            <Button>Create New Template</Button>
          </DialogTrigger>
          <DialogContent>

            <DialogHeader>
              <DialogTitle>Create New Template</DialogTitle>
            </DialogHeader>
            <div className="space-y-4 mt-4">
              <div>
                <label className="text-sm font-medium">Title</label>
                <Input
                  value={newTemplate.title}
                  onChange={(e: React.ChangeEvent<HTMLInputElement>) =>
                    setNewTemplate({ ...newTemplate, title: e.target.value })
                  }
                  placeholder="Enter template title"
                />
              </div>
              <div className="space-y-2">
                <label className="text-sm font-medium">Messages</label>
                {newTemplate.messages.map((message, index) => (
                  <div key={index} className="flex gap-2">
                    <Textarea
                      value={message}
                      onChange={(e: React.ChangeEvent<HTMLTextAreaElement>) => {
                        const newMessages = [...newTemplate.messages];
                        newMessages[index] = e.target.value;
                        setNewTemplate({ ...newTemplate, messages: newMessages });
                      }}
                      placeholder={`Enter message ${index + 1}`}
                      rows={3}
                    />
                    <Button
                      variant="outline"
                      size="icon"
                      type="button"
                      onClick={() => {
                        const newMessages = newTemplate.messages.filter((_, i) => i !== index);
                        setNewTemplate({ ...newTemplate, messages: newMessages.length ? newMessages : [''] });
                      }}
                      disabled={newTemplate.messages.length === 1}
                    >
                      ×
                    </Button>
                  </div>
                ))}
                <Button
                  type="button"
                  variant="outline"
                  onClick={() => setNewTemplate({
                    ...newTemplate,
                    messages: [...newTemplate.messages, '']
                  })}
                >
                  Add Message
                </Button>
              </div>
              <Button
                onClick={handleCreate}
                disabled={createMutation.isPending}
                className="w-full"
              >
                {createMutation.isPending ? 'Creating...' : 'Create Template'}
              </Button>
            </div>
          </DialogContent>
        </Dialog>

        <Dialog open={isUpdateOpen} onOpenChange={setIsUpdateOpen}>
          <DialogContent>
            <DialogHeader>
              <DialogTitle>Update Template</DialogTitle>
            </DialogHeader>
            <div className="space-y-4 mt-4">
              <div>
                <label className="text-sm font-medium">Title</label>
                <Input
                  value={selectedTemplate?.title ?? ''}
                  onChange={(e: React.ChangeEvent<HTMLInputElement>) =>
                    setSelectedTemplate(prev => prev ? { ...prev, title: e.target.value } : null)
                  }
                  placeholder="Enter template title"
                />
              </div>
              <div className="space-y-2">
                <label className="text-sm font-medium">Messages</label>
                {selectedTemplate?.messages.map((message, index) => (
                  <div key={index} className="flex gap-2">
                    <Textarea
                      value={message}
                      onChange={(e: React.ChangeEvent<HTMLTextAreaElement>) => {
                        const newMessages = [...(selectedTemplate?.messages ?? [])];
                        newMessages[index] = e.target.value;
                        setSelectedTemplate(prev => prev ? { ...prev, messages: newMessages } : null);
                      }}
                      placeholder={`Enter message ${index + 1}`}
                      rows={3}
                    />
                    <Button
                      variant="outline"
                      size="icon"
                      type="button"
                      onClick={() => {
                        const newMessages = selectedTemplate.messages.filter((_, i) => i !== index);
                        setSelectedTemplate(prev => prev ? { ...prev, messages: newMessages.length ? newMessages : [''] } : null);
                      }}
                      disabled={selectedTemplate.messages.length === 1}
                    >
                      ×
                    </Button>
                  </div>
                ))}
                <Button
                  type="button"
                  variant="outline"
                  onClick={() => setSelectedTemplate(prev => prev ? {
                    ...prev,
                    messages: [...prev.messages, '']
                  } : null)}
                >
                  Add Message
                </Button>
              </div>
              <Button
                onClick={() => {
                  if (!selectedTemplate?.title || !selectedTemplate?.messages[0]) {
                    toast.error('Please fill in all fields');
                    return;
                  }
                  updateMutation.mutate({
                    id: selectedTemplate.id,
                    template: {
                      title: selectedTemplate.title,
                      messages: selectedTemplate.messages
                    }
                  });
                }}
                disabled={updateMutation.isPending}
                className="w-full"
              >
                {updateMutation.isPending ? 'Updating...' : 'Update Template'}
              </Button>
            </div>
          </DialogContent>
        </Dialog>
      </div>

      <Table>
        <TableHeader>
          <TableRow>
            <TableHead>Title</TableHead>
            <TableHead>Content</TableHead>
            <TableHead>Created At</TableHead>
            <TableHead className="w-[100px]">Actions</TableHead>
          </TableRow>
        </TableHeader>
        <TableBody>
          {templates?.items?.map((template: MessageTemplate) => (
            <TableRow key={template.id}>
              <TableCell>{template.title}</TableCell>
              <TableCell className="max-w-md">
                <div className="space-y-1">
                  {template.messages.map((message, index) => (
                    <div key={index} className="truncate text-sm">
                      {index + 1}. {message}
                    </div>
                  ))}
                </div>
              </TableCell>
              <TableCell>
                {new Date(template.createdAt).toLocaleDateString()}
              </TableCell>
              <TableCell>
                <div className="flex gap-2">
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={() => {
                      setSelectedTemplate(template);
                      setIsUpdateOpen(true);
                    }}
                  >
                    Edit
                  </Button>
                  <Button
                    variant="destructive"
                    size="sm"
                    onClick={() => handleDelete(template.id)}
                    disabled={deleteMutation.isPending}
                  >
                    Delete
                  </Button>
                </div>
              </TableCell>
            </TableRow>
          ))}
        </TableBody>
      </Table>
    </div>
  );
}

```

# frontend/src/app/test/page.tsx

```tsx
'use client';

import { WebSocketTest } from '@/components/WebSocketTest';

export default function TestPage() {
  return (
    <main className="container mx-auto p-4">
      <h1 className="text-2xl font-bold mb-6">WebSocket Connection Test</h1>
      <WebSocketTest />
    </main>
  );
}

```

# frontend/src/components/AdScheduler.tsx

```tsx
import { useState } from 'react';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { adJobApi } from '@/services/api';
import { format, parseISO, isAfter, isBefore, addDays } from 'date-fns';

interface ScheduleSettings {
  startDate: string;
  startTime: string;
  endDate?: string;
  endTime?: string;
  repeatDaily?: boolean;
  repeatWeekly?: boolean;
  daysOfWeek?: string[];
  timeSlots?: { start: string; end: string }[];
}

interface AdJob {
  id: number;
  templateId: number;
  status: string;
  schedule?: ScheduleSettings;
  messagesSent: number;
  messagesDelivered: number;
  createdAt: string;
}

interface AdSchedulerProps {
  jobId: number;
  onScheduleSubmit: (schedule: ScheduleSettings) => void;
}

export function AdScheduler({ jobId, onScheduleSubmit }: AdSchedulerProps) {
  const queryClient = useQueryClient();
  const [schedule, setSchedule] = useState<ScheduleSettings>({
    startDate: format(addDays(new Date(), 1), 'yyyy-MM-dd'),
    startTime: '09:00',
    daysOfWeek: [],
    timeSlots: [{ start: '09:00', end: '17:00' }],
  });

  // Fetch job details
  const { data: job } = useQuery({
    queryKey: ['job', jobId],
    queryFn: async () => {
      const response = await adJobApi.getJob(jobId);
      return response.data;
    },
  });

  // Update job schedule mutation
  const updateScheduleMutation = useMutation({
    mutationFn: async (schedule: ScheduleSettings) => {
      const response = await adJobApi.updateJobSchedule(jobId, schedule);
      return response.data;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['job', jobId] });
    },
  });

  const handleDayToggle = (day: string) => {
    setSchedule((prev) => ({
      ...prev,
      daysOfWeek: prev.daysOfWeek?.includes(day)
        ? prev.daysOfWeek.filter((d) => d !== day)
        : [...(prev.daysOfWeek || []), day],
    }));
  };

  const handleAddTimeSlot = () => {
    setSchedule((prev) => ({
      ...prev,
      timeSlots: [
        ...(prev.timeSlots || []),
        { start: '09:00', end: '17:00' },
      ],
    }));
  };

  const handleRemoveTimeSlot = (index: number) => {
    setSchedule((prev) => ({
      ...prev,
      timeSlots: prev.timeSlots?.filter((_, i) => i !== index),
    }));
  };

  const handleUpdateTimeSlot = (
    index: number,
    field: 'start' | 'end',
    value: string
  ) => {
    setSchedule((prev) => ({
      ...prev,
      timeSlots: prev.timeSlots?.map((slot, i) =>
        i === index ? { ...slot, [field]: value } : slot
      ),
    }));
  };

  const handleSaveSchedule = () => {
    updateScheduleMutation.mutate(schedule);
    onScheduleSubmit(schedule);
  };

  return (
    <div className="bg-white shadow sm:rounded-lg">
      <div className="px-4 py-5 sm:p-6">
        <h3 className="text-base font-semibold leading-6 text-gray-900">
          Schedule Campaign
        </h3>
        <div className="mt-6 grid grid-cols-1 gap-y-6 gap-x-4 sm:grid-cols-6">
          {/* Start Date & Time */}
          <div className="sm:col-span-3">
            <label
              htmlFor="start-date"
              className="block text-sm font-medium text-gray-700"
            >
              Start Date
            </label>
            <div className="mt-1">
              <input
                type="date"
                name="start-date"
                id="start-date"
                value={schedule.startDate}
                onChange={(e) =>
                  setSchedule((prev) => ({
                    ...prev,
                    startDate: e.target.value,
                  }))
                }
                className="block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm"
              />
            </div>
          </div>

          <div className="sm:col-span-3">
            <label
              htmlFor="start-time"
              className="block text-sm font-medium text-gray-700"
            >
              Start Time
            </label>
            <div className="mt-1">
              <input
                type="time"
                name="start-time"
                id="start-time"
                value={schedule.startTime}
                onChange={(e) =>
                  setSchedule((prev) => ({
                    ...prev,
                    startTime: e.target.value,
                  }))
                }
                className="block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm"
              />
            </div>
          </div>

          {/* Repeat Options */}
          <div className="sm:col-span-6">
            <fieldset className="space-y-4">
              <legend className="text-sm font-medium text-gray-700">
                Repeat Options
              </legend>
              <div className="flex items-center space-x-4">
                <label className="flex items-center">
                  <input
                    type="checkbox"
                    checked={schedule.repeatDaily}
                    onChange={(e) =>
                      setSchedule((prev) => ({
                        ...prev,
                        repeatDaily: e.target.checked,
                        repeatWeekly: e.target.checked
                          ? false
                          : prev.repeatWeekly,
                      }))
                    }
                    className="h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500"
                  />
                  <span className="ml-2 text-sm text-gray-700">Daily</span>
                </label>
                <label className="flex items-center">
                  <input
                    type="checkbox"
                    checked={schedule.repeatWeekly}
                    onChange={(e) =>
                      setSchedule((prev) => ({
                        ...prev,
                        repeatWeekly: e.target.checked,
                        repeatDaily: e.target.checked ? false : prev.repeatDaily,
                      }))
                    }
                    className="h-4 w-4 rounded border-gray-300 text-indigo-600 focus:ring-indigo-500"
                  />
                  <span className="ml-2 text-sm text-gray-700">Weekly</span>
                </label>
              </div>
            </fieldset>
          </div>

          {/* Days of Week */}
          {schedule.repeatWeekly && (
            <div className="sm:col-span-6">
              <fieldset>
                <legend className="text-sm font-medium text-gray-700">
                  Days of Week
                </legend>
                <div className="mt-2 flex flex-wrap gap-3">
                  {['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'].map(
                    (day) => (
                      <label
                        key={day}
                        className="relative flex items-center justify-center"
                      >
                        <input
                          type="checkbox"
                          checked={schedule.daysOfWeek?.includes(day)}
                          onChange={() => handleDayToggle(day)}
                          className="sr-only"
                        />
                        <span
                          className={`flex h-8 w-12 items-center justify-center rounded-full text-sm font-medium ${
                            schedule.daysOfWeek?.includes(day)
                              ? 'bg-indigo-600 text-white'
                              : 'bg-gray-100 text-gray-700 hover:bg-gray-200'
                          }`}
                        >
                          {day}
                        </span>
                      </label>
                    )
                  )}
                </div>
              </fieldset>
            </div>
          )}

          {/* Time Slots */}
          <div className="sm:col-span-6">
            <div className="flex items-center justify-between">
              <label className="block text-sm font-medium text-gray-700">
                Time Slots
              </label>
              <button
                type="button"
                onClick={handleAddTimeSlot}
                className="inline-flex items-center rounded-md border border-transparent bg-indigo-100 px-3 py-2 text-sm font-medium leading-4 text-indigo-700 hover:bg-indigo-200 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2"
              >
                Add Slot
              </button>
            </div>
            <div className="mt-2 space-y-3">
              {schedule.timeSlots?.map((slot, index) => (
                <div key={index} className="flex items-center space-x-3">
                  <input
                    type="time"
                    value={slot.start}
                    onChange={(e) =>
                      handleUpdateTimeSlot(index, 'start', e.target.value)
                    }
                    className="block rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm"
                  />
                  <span className="text-gray-500">to</span>
                  <input
                    type="time"
                    value={slot.end}
                    onChange={(e) =>
                      handleUpdateTimeSlot(index, 'end', e.target.value)
                    }
                    className="block rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm"
                  />
                  <button
                    type="button"
                    onClick={() => handleRemoveTimeSlot(index)}
                    className="inline-flex items-center rounded-md border border-transparent bg-red-100 px-3 py-2 text-sm font-medium leading-4 text-red-700 hover:bg-red-200 focus:outline-none focus:ring-2 focus:ring-red-500 focus:ring-offset-2"
                  >
                    Remove
                  </button>
                </div>
              ))}
            </div>
          </div>
        </div>

        <div className="mt-6 flex justify-end">
          <button
            type="button"
            onClick={handleSaveSchedule}
            disabled={updateScheduleMutation.isPending}
            className="inline-flex items-center rounded-md border border-transparent bg-indigo-600 px-4 py-2 text-sm font-medium text-white shadow-sm hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2"
          >
            {updateScheduleMutation.isPending ? 'Saving...' : 'Save Schedule'}
          </button>
        </div>
      </div>
    </div>
  );
}

```

# frontend/src/components/AnalyticsDashboard.tsx

```tsx
import { useState } from 'react';
import { useQuery } from '@tanstack/react-query';
import { adJobApi } from '@/services/api';
import {
  BarChart,
  Bar,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  Legend,
  ResponsiveContainer,
  LineChart,
  Line,
} from 'recharts';
import { format, subDays, startOfDay, endOfDay } from 'date-fns';

interface AdJob {
  id: number;
  templateId: number;
  status: string;
  messagesSent: number;
  messagesDelivered: number;
  createdAt: string;
}

interface DailyStats {
  date: string;
  sent: number;
  delivered: number;
  deliveryRate: number;
}

interface TemplateStats {
  templateId: number;
  sent: number;
  delivered: number;
  deliveryRate: number;
}

export function AnalyticsDashboard() {
  const [dateRange, setDateRange] = useState<'7d' | '30d' | '90d'>('7d');

  // Fetch all jobs
  const { data: jobs } = useQuery({
    queryKey: ['jobs'],
    queryFn: async () => {
      const response = await adJobApi.getJobs();
      return response.data;
    },
  });

  // Calculate date range
  const getDaysForRange = (range: '7d' | '30d' | '90d') => {
    switch (range) {
      case '7d':
        return 7;
      case '30d':
        return 30;
      case '90d':
        return 90;
    }
  };

  // Process jobs data for charts
  const processJobsData = (jobs: AdJob[] | undefined) => {
    if (!jobs) return { dailyStats: [], templateStats: [] };

    const days = getDaysForRange(dateRange);
    const startDate = startOfDay(subDays(new Date(), days - 1));
    const endDate = endOfDay(new Date());

    // Filter jobs within date range
    const filteredJobs = jobs.filter((job) => {
      const jobDate = new Date(job.createdAt);
      return jobDate >= startDate && jobDate <= endDate;
    });

    // Calculate daily stats
    const dailyStats: DailyStats[] = [];
    for (let i = 0; i < days; i++) {
      const date = subDays(new Date(), i);
      const dayStart = startOfDay(date);
      const dayEnd = endOfDay(date);

      const dayJobs = filteredJobs.filter((job) => {
        const jobDate = new Date(job.createdAt);
        return jobDate >= dayStart && jobDate <= dayEnd;
      });

      const sent = dayJobs.reduce((sum, job) => sum + job.messagesSent, 0);
      const delivered = dayJobs.reduce(
        (sum, job) => sum + job.messagesDelivered,
        0
      );

      dailyStats.unshift({
        date: format(date, 'MMM d'),
        sent,
        delivered,
        deliveryRate: sent > 0 ? (delivered / sent) * 100 : 0,
      });
    }

    // Calculate template stats
    const templateStats: TemplateStats[] = Object.values(
      filteredJobs.reduce((acc: { [key: number]: TemplateStats }, job) => {
        if (!acc[job.templateId]) {
          acc[job.templateId] = {
            templateId: job.templateId,
            sent: 0,
            delivered: 0,
            deliveryRate: 0,
          };
        }
        acc[job.templateId].sent += job.messagesSent;
        acc[job.templateId].delivered += job.messagesDelivered;
        acc[job.templateId].deliveryRate =
          (acc[job.templateId].delivered / acc[job.templateId].sent) * 100;
        return acc;
      }, {})
    );

    return { dailyStats, templateStats };
  };

  const { dailyStats, templateStats } = processJobsData(jobs);

  return (
    <div className="space-y-8">
      {/* Date range selector */}
      <div className="flex justify-end space-x-2">
        <button
          onClick={() => setDateRange('7d')}
          className={`px-3 py-1 rounded-md text-sm ${
            dateRange === '7d'
              ? 'bg-indigo-600 text-white'
              : 'bg-gray-100 text-gray-700 hover:bg-gray-200'
          }`}
        >
          7 Days
        </button>
        <button
          onClick={() => setDateRange('30d')}
          className={`px-3 py-1 rounded-md text-sm ${
            dateRange === '30d'
              ? 'bg-indigo-600 text-white'
              : 'bg-gray-100 text-gray-700 hover:bg-gray-200'
          }`}
        >
          30 Days
        </button>
        <button
          onClick={() => setDateRange('90d')}
          className={`px-3 py-1 rounded-md text-sm ${
            dateRange === '90d'
              ? 'bg-indigo-600 text-white'
              : 'bg-gray-100 text-gray-700 hover:bg-gray-200'
          }`}
        >
          90 Days
        </button>
      </div>

      {/* Daily metrics chart */}
      <div className="bg-white p-6 rounded-lg shadow">
        <h3 className="text-lg font-medium text-gray-900 mb-4">
          Daily Message Metrics
        </h3>
        <div className="h-80">
          <ResponsiveContainer width="100%" height="100%">
            <LineChart data={dailyStats}>
              <CartesianGrid strokeDasharray="3 3" />
              <XAxis dataKey="date" />
              <YAxis yAxisId="left" />
              <YAxis yAxisId="right" orientation="right" />
              <Tooltip />
              <Legend />
              <Line
                yAxisId="left"
                type="monotone"
                dataKey="sent"
                stroke="#4F46E5"
                name="Messages Sent"
              />
              <Line
                yAxisId="left"
                type="monotone"
                dataKey="delivered"
                stroke="#059669"
                name="Messages Delivered"
              />
              <Line
                yAxisId="right"
                type="monotone"
                dataKey="deliveryRate"
                stroke="#EAB308"
                name="Delivery Rate (%)"
              />
            </LineChart>
          </ResponsiveContainer>
        </div>
      </div>

      {/* Template performance chart */}
      <div className="bg-white p-6 rounded-lg shadow">
        <h3 className="text-lg font-medium text-gray-900 mb-4">
          Template Performance
        </h3>
        <div className="h-80">
          <ResponsiveContainer width="100%" height="100%">
            <BarChart data={templateStats}>
              <CartesianGrid strokeDasharray="3 3" />
              <XAxis dataKey="templateId" label="Template ID" />
              <YAxis />
              <Tooltip />
              <Legend />
              <Bar dataKey="sent" fill="#4F46E5" name="Messages Sent" />
              <Bar
                dataKey="delivered"
                fill="#059669"
                name="Messages Delivered"
              />
            </BarChart>
          </ResponsiveContainer>
        </div>
      </div>

      {/* Summary cards */}
      <div className="grid grid-cols-1 md:grid-cols-3 gap-6">
        <div className="bg-white p-6 rounded-lg shadow">
          <h4 className="text-sm font-medium text-gray-500">Total Messages</h4>
          <p className="mt-2 text-3xl font-semibold text-gray-900">
            {dailyStats.reduce((sum, day) => sum + day.sent, 0).toLocaleString()}
          </p>
        </div>
        <div className="bg-white p-6 rounded-lg shadow">
          <h4 className="text-sm font-medium text-gray-500">
            Messages Delivered
          </h4>
          <p className="mt-2 text-3xl font-semibold text-gray-900">
            {dailyStats
              .reduce((sum, day) => sum + day.delivered, 0)
              .toLocaleString()}
          </p>
        </div>
        <div className="bg-white p-6 rounded-lg shadow">
          <h4 className="text-sm font-medium text-gray-500">
            Average Delivery Rate
          </h4>
          <p className="mt-2 text-3xl font-semibold text-gray-900">
            {(
              (dailyStats.reduce((sum, day) => sum + day.deliveryRate, 0) /
                dailyStats.length) |
              0
            ).toFixed(1)}
            %
          </p>
        </div>
      </div>
    </div>
  );
}

```

# frontend/src/components/AudienceSelector.tsx

```tsx
import { useState, useEffect } from 'react';
import { Tab } from '@headlessui/react';
import { CheckCircleIcon, MagnifyingGlassIcon } from '@heroicons/react/24/outline';
import clsx from 'clsx';

interface Contact {
  id: number;
  name: string;
  phone: string;
}

interface Group {
  id: number;
  name: string;
  groupId: string;
}

interface PhoneBookEntry {
  id: number;
  name: string;
  phone: string;
  groupName?: string;
}

interface AudienceSelectorProps {
  onSelectionChange: (selection: {
    contacts: Contact[];
    groups: Group[];
    phoneBook: PhoneBookEntry[];
  }) => void;
  contacts: Contact[];
  groups: Group[];
  phoneBook: PhoneBookEntry[];
}

export function AudienceSelector({
  onSelectionChange,
  contacts,
  groups,
  phoneBook,
}: AudienceSelectorProps) {
  const [selectedContacts, setSelectedContacts] = useState<Set<number>>(new Set());
  const [selectedGroups, setSelectedGroups] = useState<Set<number>>(new Set());
  const [selectedPhoneBook, setSelectedPhoneBook] = useState<Set<number>>(new Set());
  const [searchQuery, setSearchQuery] = useState('');

  const [phoneBookGroups, setPhoneBookGroups] = useState<string[]>([]);
  const [selectedPhoneBookGroup, setSelectedPhoneBookGroup] = useState<string>('all');

  useEffect(() => {
    // Extract unique group names from phone book entries
    const groups = [...new Set(phoneBook.map((entry) => entry.groupName).filter(Boolean))];
    setPhoneBookGroups(groups);
  }, [phoneBook]);

  useEffect(() => {
    onSelectionChange({
      contacts: contacts.filter((c) => selectedContacts.has(c.id)),
      groups: groups.filter((g) => selectedGroups.has(g.id)),
      phoneBook: phoneBook.filter((p) => selectedPhoneBook.has(p.id)),
    });
  }, [selectedContacts, selectedGroups, selectedPhoneBook]);

  const filterBySearch = <T extends { name: string }>(items: T[]) => {
    if (!searchQuery) return items;
    return items.filter((item) =>
      item.name.toLowerCase().includes(searchQuery.toLowerCase())
    );
  };

  const filteredPhoneBook = phoneBook.filter((entry) => {
    const matchesSearch = !searchQuery || entry.name.toLowerCase().includes(searchQuery.toLowerCase());
    const matchesGroup = selectedPhoneBookGroup === 'all' || entry.groupName === selectedPhoneBookGroup;
    return matchesSearch && matchesGroup;
  });

  return (
    <div className="bg-white rounded-lg shadow">
      <Tab.Group>
        <Tab.List className="flex space-x-1 p-1 bg-indigo-50 rounded-t-lg">
          {['Contacts', 'Groups', 'Phone Book'].map((category) => (
            <Tab
              key={category}
              className={({ selected }) =>
                clsx(
                  'w-full py-2.5 text-sm font-medium leading-5 rounded-lg',
                  'focus:outline-none focus:ring-2 ring-offset-2 ring-offset-indigo-400 ring-white ring-opacity-60',
                  selected
                    ? 'bg-white shadow text-indigo-700'
                    : 'text-gray-600 hover:bg-white/[0.12] hover:text-indigo-600'
                )
              }
            >
              {category}
            </Tab>
          ))}
        </Tab.List>

        <div className="p-4">
          <div className="relative mb-4">
            <MagnifyingGlassIcon className="absolute left-3 top-1/2 transform -translate-y-1/2 h-5 w-5 text-gray-400" />
            <input
              type="text"
              value={searchQuery}
              onChange={(e) => setSearchQuery(e.target.value)}
              placeholder="Search..."
              className="w-full pl-10 pr-3 py-2 border rounded-md focus:outline-none focus:ring-2 focus:ring-indigo-500"
            />
          </div>

          <Tab.Panels>
            {/* Contacts Panel */}
            <Tab.Panel className="space-y-2">
              {filterBySearch(contacts).map((contact) => (
                <div
                  key={contact.id}
                  onClick={() => {
                    const newSelection = new Set(selectedContacts);
                    if (newSelection.has(contact.id)) {
                      newSelection.delete(contact.id);
                    } else {
                      newSelection.add(contact.id);
                    }
                    setSelectedContacts(newSelection);
                  }}
                  className={clsx(
                    'flex items-center justify-between p-3 rounded-md cursor-pointer',
                    selectedContacts.has(contact.id)
                      ? 'bg-indigo-50'
                      : 'hover:bg-gray-50'
                  )}
                >
                  <div>
                    <p className="font-medium text-gray-900">{contact.name}</p>
                    <p className="text-sm text-gray-500">{contact.phone}</p>
                  </div>
                  {selectedContacts.has(contact.id) && (
                    <CheckCircleIcon className="h-5 w-5 text-indigo-600" />
                  )}
                </div>
              ))}
            </Tab.Panel>

            {/* Groups Panel */}
            <Tab.Panel className="space-y-2">
              {filterBySearch(groups).map((group) => (
                <div
                  key={group.id}
                  onClick={() => {
                    const newSelection = new Set(selectedGroups);
                    if (newSelection.has(group.id)) {
                      newSelection.delete(group.id);
                    } else {
                      newSelection.add(group.id);
                    }
                    setSelectedGroups(newSelection);
                  }}
                  className={clsx(
                    'flex items-center justify-between p-3 rounded-md cursor-pointer',
                    selectedGroups.has(group.id)
                      ? 'bg-indigo-50'
                      : 'hover:bg-gray-50'
                  )}
                >
                  <p className="font-medium text-gray-900">{group.name}</p>
                  {selectedGroups.has(group.id) && (
                    <CheckCircleIcon className="h-5 w-5 text-indigo-600" />
                  )}
                </div>
              ))}
            </Tab.Panel>

            {/* Phone Book Panel */}
            <Tab.Panel>
              <div className="mb-4">
                <select
                  value={selectedPhoneBookGroup}
                  onChange={(e) => setSelectedPhoneBookGroup(e.target.value)}
                  className="w-full px-3 py-2 border rounded-md focus:outline-none focus:ring-2 focus:ring-indigo-500"
                >
                  <option value="all">All Groups</option>
                  {phoneBookGroups.map((group) => (
                    <option key={group} value={group}>
                      {group}
                    </option>
                  ))}
                </select>
              </div>

              <div className="space-y-2">
                {filteredPhoneBook.map((entry) => (
                  <div
                    key={entry.id}
                    onClick={() => {
                      const newSelection = new Set(selectedPhoneBook);
                      if (newSelection.has(entry.id)) {
                        newSelection.delete(entry.id);
                      } else {
                        newSelection.add(entry.id);
                      }
                      setSelectedPhoneBook(newSelection);
                    }}
                    className={clsx(
                      'flex items-center justify-between p-3 rounded-md cursor-pointer',
                      selectedPhoneBook.has(entry.id)
                        ? 'bg-indigo-50'
                        : 'hover:bg-gray-50'
                    )}
                  >
                    <div>
                      <p className="font-medium text-gray-900">{entry.name}</p>
                      <p className="text-sm text-gray-500">{entry.phone}</p>
                      {entry.groupName && (
                        <p className="text-xs text-indigo-600">{entry.groupName}</p>
                      )}
                    </div>
                    {selectedPhoneBook.has(entry.id) && (
                      <CheckCircleIcon className="h-5 w-5 text-indigo-600" />
                    )}
                  </div>
                ))}
              </div>
            </Tab.Panel>
          </Tab.Panels>
        </div>
      </Tab.Group>
    </div>
  );
}

```

# frontend/src/components/contacts/ContactList.tsx

```tsx
import { useQuery } from '@tanstack/react-query';
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from '@/components/ui/table';
import { Avatar, AvatarFallback, AvatarImage } from '@/components/ui/avatar';
import { Badge } from '@/components/ui/badge';
import { Contact, ContactFilter } from '@shared/types/contacts';
import { Skeleton } from '@/components/ui/skeleton';
import { CustomPagination } from '@/components/ui/custom-pagination';

interface ContactListProps {
  filter: ContactFilter;
  onPageChange: (page: number) => void;
}

export function ContactList({ filter, onPageChange }: ContactListProps) {
  const { data, isLoading, error } = useQuery({
    queryKey: ['contacts', filter],
    queryFn: async () => {
      const params = new URLSearchParams({
        page: String(filter.page || 1),
        pageSize: String(filter.pageSize || 20),
      });
      if (filter.search) params.append('search', filter.search);
      if (filter.isMyContact !== undefined) params.append('isMyContact', String(filter.isMyContact));

      const response = await fetch(`${process.env.NEXT_PUBLIC_API_URL}/api/whatsapp/contacts?${params}`);
      if (!response.ok) {
        const error = await response.json();
        throw new Error(error.error?.message || 'Failed to fetch contacts');
      }
      const { items, total } = (await response.json()).data;
      return { items, total };
    },
  });

  if (error) {
    return (
      <div className="text-center py-4 text-red-500">
        Error loading contacts. Please try again later.
      </div>
    );
  }

  return (
    <div className="space-y-4">
      <div className="rounded-md border">
        <Table>
          <TableHeader>
            <TableRow>
              <TableHead>Contact</TableHead>
              <TableHead>Phone Number</TableHead>
              <TableHead>Status</TableHead>
              <TableHead>Last Seen</TableHead>
              <TableHead>Type</TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            {isLoading ? (
              Array.from({ length: 5 }).map((_, i) => (
                <TableRow key={i}>
                  <TableCell>
                    <div className="flex items-center gap-3">
                      <Skeleton className="h-10 w-10 rounded-full" />
                      <Skeleton className="h-4 w-32" />
                    </div>
                  </TableCell>
                  <TableCell><Skeleton className="h-4 w-24" /></TableCell>
                  <TableCell><Skeleton className="h-4 w-20" /></TableCell>
                  <TableCell><Skeleton className="h-4 w-24" /></TableCell>
                  <TableCell><Skeleton className="h-4 w-16" /></TableCell>
                </TableRow>
              ))
            ) : data?.items?.map((contact: Contact) => (
              <TableRow key={contact.id}>
                <TableCell>
                  <div className="flex items-center gap-3">
                    <Avatar>
                      <AvatarImage src={contact.profilePicUrl} />
                      <AvatarFallback>{contact.name.slice(0, 2).toUpperCase()}</AvatarFallback>
                    </Avatar>
                    <div>
                      <div className="font-medium">{contact.name}</div>
                    </div>
                  </div>
                </TableCell>
                <TableCell>{contact.phoneNumber}</TableCell>
                <TableCell>{contact.status || 'No status'}</TableCell>
                <TableCell>
                  {contact.lastSeen 
                    ? new Date(contact.lastSeen).toLocaleDateString()
                    : 'Unknown'
                  }
                </TableCell>
                <TableCell>
                  <Badge variant={contact.isMyContact ? 'default' : 'secondary'}>
                    {contact.isMyContact ? 'Contact' : 'Non-contact'}
                  </Badge>
                </TableCell>
              </TableRow>
            ))}
          </TableBody>
        </Table>
      </div>

      {data && (
        <CustomPagination
          currentPage={filter.page || 1}
          pageSize={filter.pageSize || 20}
          totalItems={data.total}
          onPageChange={onPageChange}
        />
      )}
    </div>
  );
}

```

# frontend/src/components/contacts/GroupList.tsx

```tsx
import { useQuery } from '@tanstack/react-query';
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from '@/components/ui/table';
import { Avatar, AvatarFallback, AvatarImage } from '@/components/ui/avatar';
import { Badge } from '@/components/ui/badge';
import { Group, GroupFilter } from '@shared/types/contacts';
import { Skeleton } from '@/components/ui/skeleton';
import { UsersIcon } from 'lucide-react';
import { CustomPagination } from '../ui/custom-pagination';

interface GroupListProps {
  filter: GroupFilter;
  onPageChange: (page: number) => void;
}

export function GroupList({ filter, onPageChange }: GroupListProps) {
  const { data, isLoading, error } = useQuery({
    queryKey: ['groups', filter],
    queryFn: async () => {
      const params = new URLSearchParams();
      if (filter.search) params.append('search', filter.search);
      if (filter.isAdmin !== undefined) params.append('isAdmin', String(filter.isAdmin));
      if (filter.page) params.append('page', String(filter.page));
      if (filter.pageSize) params.append('pageSize', String(filter.pageSize));

      const response = await fetch(`${process.env.NEXT_PUBLIC_API_URL}/api/groups?${params}`);
      if (!response.ok) throw new Error('Failed to fetch groups');
      return response.json();
    },
  });

  if (error) {
    return (
      <div className="text-center py-4 text-red-500">
        Error loading groups. Please try again later.
      </div>
    );
  }

  return (
    <div className="space-y-4">
      <div className="rounded-md border">
        <Table>
          <TableHeader>
            <TableRow>
              <TableHead>Group</TableHead>
              <TableHead>Description</TableHead>
              <TableHead>Members</TableHead>
              <TableHead>Created</TableHead>
              <TableHead>Role</TableHead>
            </TableRow>
          </TableHeader>
          <TableBody>
            {isLoading ? (
              Array.from({ length: 5 }).map((_, i) => (
                <TableRow key={i}>
                  <TableCell>
                    <div className="flex items-center gap-3">
                      <Skeleton className="h-10 w-10 rounded-full" />
                      <Skeleton className="h-4 w-32" />
                    </div>
                  </TableCell>
                  <TableCell><Skeleton className="h-4 w-40" /></TableCell>
                  <TableCell><Skeleton className="h-4 w-20" /></TableCell>
                  <TableCell><Skeleton className="h-4 w-24" /></TableCell>
                  <TableCell><Skeleton className="h-4 w-16" /></TableCell>
                </TableRow>
              ))
            ) : data?.groups.map((group: Group) => (
              <TableRow key={group.id}>
                <TableCell>
                  <div className="flex items-center gap-3">
                    <Avatar>
                      <AvatarImage src={group.profilePicUrl} />
                      <AvatarFallback>{group.name.slice(0, 2).toUpperCase()}</AvatarFallback>
                    </Avatar>
                    <div>
                      <div className="font-medium">{group.name}</div>
                    </div>
                  </div>
                </TableCell>
                <TableCell>
                  <div className="max-w-xs truncate">
                    {group.description || 'No description'}
                  </div>
                </TableCell>
                <TableCell>
                  <div className="flex items-center gap-1">
                    <UsersIcon className="w-4 h-4" />
                    {group.participants.length}
                  </div>
                </TableCell>
                <TableCell>
                  {new Date(group.createdAt).toLocaleDateString()}
                </TableCell>
                <TableCell>
                  <Badge variant={group.isAdmin ? 'default' : 'secondary'}>
                    {group.isAdmin ? 'Admin' : 'Member'}
                  </Badge>
                </TableCell>
              </TableRow>
            ))}
          </TableBody>
        </Table>
      </div>

      {data && (
        <CustomPagination
          currentPage={filter.page || 1}
          pageSize={filter.pageSize || 20}
          totalItems={data.total}
          onPageChange={onPageChange}
        />
      )}
    </div>
  );
}

```

# frontend/src/components/layout/MainLayout.tsx

```tsx
'use client';

import { Fragment, useState } from 'react';
import { Dialog, Transition } from '@headlessui/react';
import {
  Bars3Icon,
  HomeIcon,
  UsersIcon,
  ChatBubbleLeftRightIcon,
  ClipboardDocumentListIcon,
  ChartBarIcon,
  CalendarIcon,
  XMarkIcon,
} from '@heroicons/react/24/outline';
import { useWebSocket } from '@/hooks/useWebSocket';
import { WhatsAppQRCode } from '@/components/WhatsAppQRCode';
import Link from 'next/link';
import { usePathname } from 'next/navigation';
import { cn } from '@/lib/utils';

const navigation = [
  { name: 'Dashboard', href: '/', icon: HomeIcon },
  { name: 'Contacts & Groups', href: '/contacts', icon: UsersIcon },
  { name: 'Message Templates', href: '/templates', icon: ChatBubbleLeftRightIcon },
  { name: 'Ad Jobs', href: '/jobs', icon: ClipboardDocumentListIcon },
  { name: 'Analytics', href: '/analytics', icon: ChartBarIcon },
  { name: 'Schedule', href: '/schedule', icon: CalendarIcon },
];

interface MainLayoutProps {
  children: React.ReactNode;
}

export default function MainLayout({ children }: MainLayoutProps) {
  const [sidebarOpen, setSidebarOpen] = useState(false);
  const pathname = usePathname();
  const { status } = useWebSocket();

  return (
    <>
      <div>
        <Transition.Root show={sidebarOpen} as={Fragment}>
          <Dialog as="div" className="relative z-50 lg:hidden" onClose={setSidebarOpen}>
            <Transition.Child
              as={Fragment}
              enter="transition-opacity ease-linear duration-300"
              enterFrom="opacity-0"
              enterTo="opacity-100"
              leave="transition-opacity ease-linear duration-300"
              leaveFrom="opacity-100"
              leaveTo="opacity-0"
            >
              <div className="fixed inset-0 bg-gray-900/80" />
            </Transition.Child>

            <div className="fixed inset-0 flex">
              <Transition.Child
                as={Fragment}
                enter="transition ease-in-out duration-300 transform"
                enterFrom="-translate-x-full"
                enterTo="translate-x-0"
                leave="transition ease-in-out duration-300 transform"
                leaveFrom="translate-x-0"
                leaveTo="-translate-x-full"
              >
                <Dialog.Panel className="relative mr-16 flex w-full max-w-xs flex-1">
                  <div className="flex grow flex-col gap-y-5 overflow-y-auto bg-white px-6 pb-4">
                    <div className="flex h-16 shrink-0 items-center">
                      <img
                        className="h-8 w-auto"
                        src="/logo.svg"
                        alt="WhatsApp Ads"
                      />
                    </div>
                    <nav className="flex flex-1 flex-col">
                      <ul role="list" className="flex flex-1 flex-col gap-y-7">
                        <li>
                          <ul role="list" className="-mx-2 space-y-1">
                            {navigation.map((item) => (
                              <li key={item.name}>
                                <Link
                                  href={item.href}
                                  className={cn(
                                    pathname === item.href
                                      ? 'bg-gray-50 text-indigo-600'
                                      : 'text-gray-700 hover:text-indigo-600 hover:bg-gray-50',
                                    'group flex gap-x-3 rounded-md p-2 text-sm leading-6 font-semibold'
                                  )}
                                >
                                  <item.icon
                                    className={cn(
                                      pathname === item.href
                                        ? 'text-indigo-600'
                                        : 'text-gray-400 group-hover:text-indigo-600',
                                      'h-6 w-6 shrink-0'
                                    )}
                                    aria-hidden="true"
                                  />
                                  {item.name}
                                </Link>
                              </li>
                            ))}
                          </ul>
                        </li>
                      </ul>
                    </nav>
                  </div>
                </Dialog.Panel>
              </Transition.Child>
            </div>
          </Dialog>
        </Transition.Root>

        {/* Static sidebar for desktop */}
        <div className="hidden lg:fixed lg:inset-y-0 lg:z-50 lg:flex lg:w-72 lg:flex-col">
          <div className="flex grow flex-col gap-y-5 overflow-y-auto border-r border-gray-200 bg-white px-6 pb-4">
            <div className="flex h-16 shrink-0 items-center">
              <img
                className="h-8 w-auto"
                src="/logo.svg"
                alt="WhatsApp Ads"
              />
            </div>
            <nav className="flex flex-1 flex-col">
              <ul role="list" className="flex flex-1 flex-col gap-y-7">
                <li>
                  <ul role="list" className="-mx-2 space-y-1">
                    {navigation.map((item) => (
                      <li key={item.name}>
                        <Link
                          href={item.href}
                          className={cn(
                            pathname === item.href
                              ? 'bg-gray-50 text-indigo-600'
                              : 'text-gray-700 hover:text-indigo-600 hover:bg-gray-50',
                            'group flex gap-x-3 rounded-md p-2 text-sm leading-6 font-semibold'
                          )}
                        >
                          <item.icon
                            className={cn(
                              pathname === item.href
                                ? 'text-indigo-600'
                                : 'text-gray-400 group-hover:text-indigo-600',
                              'h-6 w-6 shrink-0'
                            )}
                            aria-hidden="true"
                          />
                          {item.name}
                        </Link>
                      </li>
                    ))}
                  </ul>
                </li>
                <li className="mt-auto">
                  <div className="px-2 py-3">
                    <div className="flex items-center gap-x-3 text-sm font-semibold leading-6 text-gray-900">
                      <div className={cn(
                        'h-2.5 w-2.5 rounded-full',
                        status.isConnected ? 'bg-green-500' : status.qrCode ? 'bg-yellow-500' : 'bg-red-500'
                      )} />
                      <span>WhatsApp Status</span>
                    </div>
                    <p className="mt-1 text-xs text-gray-600">
                      {status.isConnected ? 'Connected and ready' :
                       status.qrCode ? 'Scan QR code in dashboard' :
                       'Initializing connection...'}
                    </p>
                  </div>
                </li>
              </ul>
            </nav>
          </div>
        </div>

        <div className="lg:pl-72">
          <div className="sticky top-0 z-40 flex h-16 shrink-0 items-center gap-x-4 border-b border-gray-200 bg-white px-4 shadow-sm sm:gap-x-6 sm:px-6 lg:px-8">
            <button
              type="button"
              className="-m-2.5 p-2.5 text-gray-700 lg:hidden"
              onClick={() => setSidebarOpen(true)}
            >
              <span className="sr-only">Open sidebar</span>
              <Bars3Icon className="h-6 w-6" aria-hidden="true" />
            </button>

            {/* Separator */}
            <div className="h-6 w-px bg-gray-200 lg:hidden" aria-hidden="true" />

            <div className="flex flex-1 gap-x-4 self-stretch lg:gap-x-6">
              <div className="flex flex-1" />
            </div>
          </div>

          <main className="py-10">
            <div className="px-4 sm:px-6 lg:px-8">
              {children}
            </div>
          </main>
        </div>
      </div>
    </>
  );
}

```

# frontend/src/components/MessageTemplateEditor.tsx

```tsx
import { useState } from 'react';
import { PaperAirplaneIcon, PhotoIcon } from '@heroicons/react/24/outline';

interface Message {
  type: 'text' | 'media';
  content: string;
  caption?: string;
}

interface MessageTemplateEditorProps {
  onSave: (title: string, messages: Message[]) => void;
  initialTitle?: string;
  initialMessages?: Message[];
}

export function MessageTemplateEditor({
  onSave,
  initialTitle = '',
  initialMessages = [],
}: MessageTemplateEditorProps) {
  const [title, setTitle] = useState(initialTitle);
  const [messages, setMessages] = useState<Message[]>(initialMessages);
  const [currentMessage, setCurrentMessage] = useState('');
  const [mediaUrl, setMediaUrl] = useState('');
  const [mediaCaption, setMediaCaption] = useState('');
  const [isAddingMedia, setIsAddingMedia] = useState(false);

  const handleAddTextMessage = () => {
    if (!currentMessage.trim()) return;
    setMessages([...messages, { type: 'text', content: currentMessage }]);
    setCurrentMessage('');
  };

  const handleAddMediaMessage = () => {
    if (!mediaUrl.trim()) return;
    setMessages([
      ...messages,
      {
        type: 'media',
        content: mediaUrl,
        caption: mediaCaption.trim() || undefined,
      },
    ]);
    setMediaUrl('');
    setMediaCaption('');
    setIsAddingMedia(false);
  };

  const handleSave = () => {
    if (!title.trim() || messages.length === 0) return;
    onSave(title, messages);
  };

  return (
    <div className="flex flex-col h-full bg-white rounded-lg shadow">
      {/* Template Title */}
      <div className="p-4 border-b">
        <input
          type="text"
          value={title}
          onChange={(e) => setTitle(e.target.value)}
          placeholder="Template Title"
          className="w-full px-3 py-2 border rounded-md focus:outline-none focus:ring-2 focus:ring-indigo-500"
        />
      </div>

      {/* Message Preview */}
      <div className="flex-1 p-4 space-y-4 overflow-y-auto">
        {messages.map((message, index) => (
          <div
            key={index}
            className="flex flex-col max-w-[80%] ml-auto bg-indigo-50 rounded-lg p-3"
          >
            {message.type === 'media' && (
              <div className="mb-2">
                <img
                  src={message.content}
                  alt="Media preview"
                  className="max-w-full rounded"
                  onError={(e) => {
                    (e.target as HTMLImageElement).src = '/placeholder-image.png';
                  }}
                />
                {message.caption && (
                  <p className="mt-2 text-sm text-gray-600">{message.caption}</p>
                )}
              </div>
            )}
            {message.type === 'text' && (
              <p className="text-gray-800">{message.content}</p>
            )}
          </div>
        ))}
      </div>

      {/* Message Input */}
      <div className="p-4 border-t">
        {isAddingMedia ? (
          <div className="space-y-3">
            <input
              type="text"
              value={mediaUrl}
              onChange={(e) => setMediaUrl(e.target.value)}
              placeholder="Media URL"
              className="w-full px-3 py-2 border rounded-md focus:outline-none focus:ring-2 focus:ring-indigo-500"
            />
            <input
              type="text"
              value={mediaCaption}
              onChange={(e) => setMediaCaption(e.target.value)}
              placeholder="Caption (optional)"
              className="w-full px-3 py-2 border rounded-md focus:outline-none focus:ring-2 focus:ring-indigo-500"
            />
            <div className="flex justify-end gap-2">
              <button
                onClick={() => setIsAddingMedia(false)}
                className="px-4 py-2 text-sm text-gray-600 hover:text-gray-800"
              >
                Cancel
              </button>
              <button
                onClick={handleAddMediaMessage}
                className="px-4 py-2 text-sm text-white bg-indigo-600 rounded-md hover:bg-indigo-700"
              >
                Add Media
              </button>
            </div>
          </div>
        ) : (
          <div className="flex items-center gap-2">
            <input
              type="text"
              value={currentMessage}
              onChange={(e) => setCurrentMessage(e.target.value)}
              onKeyDown={(e) => {
                if (e.key === 'Enter' && !e.shiftKey) {
                  e.preventDefault();
                  handleAddTextMessage();
                }
              }}
              placeholder="Type a message..."
              className="flex-1 px-3 py-2 border rounded-md focus:outline-none focus:ring-2 focus:ring-indigo-500"
            />
            <button
              onClick={() => setIsAddingMedia(true)}
              className="p-2 text-gray-500 hover:text-gray-700"
            >
              <PhotoIcon className="w-5 h-5" />
            </button>
            <button
              onClick={handleAddTextMessage}
              className="p-2 text-white bg-indigo-600 rounded-md hover:bg-indigo-700"
            >
              <PaperAirplaneIcon className="w-5 h-5" />
            </button>
          </div>
        )}
      </div>

      {/* Save Button */}
      <div className="p-4 border-t">
        <button
          onClick={handleSave}
          disabled={!title.trim() || messages.length === 0}
          className="w-full px-4 py-2 text-white bg-indigo-600 rounded-md hover:bg-indigo-700 disabled:opacity-50 disabled:cursor-not-allowed"
        >
          Save Template
        </button>
      </div>
    </div>
  );
}

```

# frontend/src/components/ModerationPanel.tsx

```tsx
import { useState } from 'react';
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import {
  CheckCircleIcon,
  XCircleIcon,
  PlayCircleIcon,
  StopCircleIcon,
} from '@heroicons/react/24/outline';
import { format } from 'date-fns';
import { ModerationLog } from '@/types';
import { moderationApi, adJobApi } from '@/services/api';

type JobStatus = 'pending' | 'approved' | 'rejected' | 'running' | 'completed' | 'failed' | 'stopped';

interface AdJob {
  id: number;
  templateId: number;
  status: JobStatus;
  audience: string;
  createdAt: string;
  messagesDelivered?: number;
  messagesSent?: number;
}

interface ModerationAction {
  jobId: number;
  action: 'approved' | 'rejected';
  moderator: string;
  notes?: string;
}

export function ModerationPanel() {
  const queryClient = useQueryClient();
  const [selectedJob, setSelectedJob] = useState<AdJob | null>(null);
  const [moderationNotes, setModerationNotes] = useState('');

  const { data: pendingJobs } = useQuery({
    queryKey: ['pending-jobs'],
    queryFn: async () => {
      const response = await moderationApi.getModerationQueue();
      return response.data;
    },
  });

  const moderateMutation = useMutation<ModerationLog, Error, ModerationAction>({
    mutationFn: async (action: ModerationAction) => {
      const response = await moderationApi.moderateJob(action.jobId, action.action, action.notes);
      return response.data;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['pending-jobs'] });
      setSelectedJob(null);
      setModerationNotes('');
    },
  });

  const jobControlMutation = useMutation<AdJob, Error, { jobId: number; action: 'start' | 'stop' }>({
    mutationFn: async ({ jobId, action }) => {
      const response = await adJobApi.updateJobStatus(jobId, action === 'start' ? 'running' : 'stopped');
      return response.data;
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ['pending-jobs'] });
    },
  });

  const handleModeration = (action: 'approved' | 'rejected') => {
    if (!selectedJob) return;

    moderateMutation.mutate({
      jobId: selectedJob.id,
      action,
      moderator: 'Admin', // TODO: Get from auth context
      notes: moderationNotes,
    });
  };

  const handleJobControl = (jobId: number, action: 'start' | 'stop') => {
    jobControlMutation.mutate({ jobId, action });
  };

  return (
    <div className="bg-white shadow sm:rounded-lg">
      <div className="px-4 py-5 sm:p-6">
        <div className="sm:flex sm:items-center sm:justify-between">
          <div>
            <h3 className="text-base font-semibold leading-6 text-gray-900">
              Moderation Queue
            </h3>
            <p className="mt-1 text-sm text-gray-500">
              Review and manage pending ad jobs
            </p>
          </div>
        </div>

        <div className="mt-6 flow-root">
          <div className="-mx-4 -my-2 overflow-x-auto sm:-mx-6 lg:-mx-8">
            <div className="inline-block min-w-full py-2 align-middle sm:px-6 lg:px-8">
              <table className="min-w-full divide-y divide-gray-300">
                <thead>
                  <tr>
                    <th className="py-3.5 pl-4 pr-3 text-left text-sm font-semibold text-gray-900">
                      Template
                    </th>
                    <th className="px-3 py-3.5 text-left text-sm font-semibold text-gray-900">
                      Status
                    </th>
                    <th className="px-3 py-3.5 text-left text-sm font-semibold text-gray-900">
                      Progress
                    </th>
                    <th className="px-3 py-3.5 text-left text-sm font-semibold text-gray-900">
                      Created
                    </th>
                    <th className="px-3 py-3.5 text-left text-sm font-semibold text-gray-900">
                      Actions
                    </th>
                  </tr>
                </thead>
                <tbody className="divide-y divide-gray-200">
                  {pendingJobs?.map((job) => (
                    <tr
                      key={job.id}
                      className={
                        selectedJob?.id === job.id ? 'bg-indigo-50' : undefined
                      }
                    >
                      <td className="whitespace-nowrap py-4 pl-4 pr-3 text-sm">
                        <button
                          onClick={() => setSelectedJob(job)}
                          className="font-medium text-indigo-600 hover:text-indigo-500"
                        >
                          Template #{job.templateId}
                        </button>
                      </td>
                      <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">
                        {job.status}
                      </td>
                      <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">
                        {job.messagesDelivered}/{job.messagesSent}
                      </td>
                      <td className="whitespace-nowrap px-3 py-4 text-sm text-gray-500">
                        {format(new Date(job.createdAt), 'MMM d, yyyy')}
                      </td>
                      <td className="whitespace-nowrap px-3 py-4 text-sm">
                        <div className="flex items-center space-x-2">
                          {(job.status === 'approved' || job.status === 'running' || job.status === 'stopped') && (
                            <>
                              {job.status === 'approved' || job.status === 'stopped' ? (
                                <button
                                  onClick={() =>
                                    handleJobControl(job.id, 'start')
                                  }
                                  className="text-green-600 hover:text-green-700"
                                >
                                  <PlayCircleIcon className="h-5 w-5" />
                                </button>
                              ) : (
                                <button
                                  onClick={() => handleJobControl(job.id, 'stop')}
                                  className="text-red-600 hover:text-red-700"
                                >
                                  <StopCircleIcon className="h-5 w-5" />
                                </button>
                              )}
                            </>
                          )}
                        </div>
                      </td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>
          </div>
        </div>

        {/* Moderation Dialog */}
        {selectedJob && (
          <div className="mt-6 bg-gray-50 p-4 rounded-lg">
            <h4 className="text-lg font-medium text-gray-900 mb-4">
              Moderate Job #{selectedJob.id}
            </h4>
            <div className="space-y-4">
              <div>
                <label
                  htmlFor="notes"
                  className="block text-sm font-medium text-gray-700"
                >
                  Moderation Notes
                </label>
                <textarea
                  id="notes"
                  rows={3}
                  value={moderationNotes}
                  onChange={(e) => setModerationNotes(e.target.value)}
                  className="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm"
                />
              </div>
              <div className="flex justify-end space-x-3">
                <button
                  onClick={() => setSelectedJob(null)}
                  className="px-4 py-2 text-sm text-gray-700 hover:text-gray-900"
                >
                  Cancel
                </button>
                <button
                  onClick={() => handleModeration('rejected')}
                  className="inline-flex items-center px-4 py-2 text-sm text-white bg-red-600 rounded-md hover:bg-red-700"
                >
                  <XCircleIcon className="h-5 w-5 mr-2" />
                  Reject
                </button>
                <button
                  onClick={() => handleModeration('approved')}
                  className="inline-flex items-center px-4 py-2 text-sm text-white bg-green-600 rounded-md hover:bg-green-700"
                >
                  <CheckCircleIcon className="h-5 w-5 mr-2" />
                  Approve
                </button>
              </div>
            </div>
          </div>
        )}
      </div>
    </div>
  );
}

```

# frontend/src/components/Navigation.tsx

```tsx
import { Fragment } from 'react';
import Link from 'next/link';
import { usePathname } from 'next/navigation';
import { Disclosure, Menu, Transition } from '@headlessui/react';
import { Bars3Icon, XMarkIcon } from '@heroicons/react/24/outline';
import clsx from 'clsx';

const navigation = [
  { name: 'Dashboard', href: '/' },
  { name: 'Message Templates', href: '/templates' },
  { name: 'Ad Jobs', href: '/jobs' },
  { name: 'Contacts & Groups', href: '/contacts' },
  { name: 'Phone Book', href: '/phonebook' },
  { name: 'Moderation', href: '/moderation' },
];

export function Navigation() {
  const pathname = usePathname();

  return (
    <Disclosure as="nav" className="bg-white shadow">
      {({ open }) => (
        <>
          <div className="mx-auto max-w-7xl px-4 sm:px-6 lg:px-8">
            <div className="flex h-16 justify-between">
              <div className="flex">
                <div className="flex flex-shrink-0 items-center">
                  <span className="text-xl font-bold text-gray-900">WhatsApp Ads</span>
                </div>
                <div className="hidden sm:ml-6 sm:flex sm:space-x-8">
                  {navigation.map((item) => (
                    <Link
                      key={item.name}
                      href={item.href}
                      className={clsx(
                        pathname === item.href
                          ? 'border-indigo-500 text-gray-900'
                          : 'border-transparent text-gray-500 hover:border-gray-300 hover:text-gray-700',
                        'inline-flex items-center border-b-2 px-1 pt-1 text-sm font-medium'
                      )}
                    >
                      {item.name}
                    </Link>
                  ))}
                </div>
              </div>
              <div className="-mr-2 flex items-center sm:hidden">
                <Disclosure.Button className="inline-flex items-center justify-center rounded-md p-2 text-gray-400 hover:bg-gray-100 hover:text-gray-500">
                  <span className="sr-only">Open main menu</span>
                  {open ? (
                    <XMarkIcon className="block h-6 w-6" aria-hidden="true" />
                  ) : (
                    <Bars3Icon className="block h-6 w-6" aria-hidden="true" />
                  )}
                </Disclosure.Button>
              </div>
            </div>
          </div>

          <Disclosure.Panel className="sm:hidden">
            <div className="space-y-1 pb-3 pt-2">
              {navigation.map((item) => (
                <Disclosure.Button
                  key={item.name}
                  as={Link}
                  href={item.href}
                  className={clsx(
                    pathname === item.href
                      ? 'bg-indigo-50 border-indigo-500 text-indigo-700'
                      : 'border-transparent text-gray-500 hover:bg-gray-50 hover:border-gray-300 hover:text-gray-700',
                    'block border-l-4 py-2 pl-3 pr-4 text-base font-medium'
                  )}
                >
                  {item.name}
                </Disclosure.Button>
              ))}
            </div>
          </Disclosure.Panel>
        </>
      )}
    </Disclosure>
  );
}

```

# frontend/src/components/ui/avatar.tsx

```tsx
"use client"

import * as React from "react"
import * as AvatarPrimitive from "@radix-ui/react-avatar"

import { cn } from "@/lib/utils"

const Avatar = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Root>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Root
    ref={ref}
    className={cn(
      "relative flex h-10 w-10 shrink-0 overflow-hidden rounded-full",
      className
    )}
    {...props}
  />
))
Avatar.displayName = AvatarPrimitive.Root.displayName

const AvatarImage = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Image>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Image>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Image
    ref={ref}
    className={cn("aspect-square h-full w-full", className)}
    {...props}
  />
))
AvatarImage.displayName = AvatarPrimitive.Image.displayName

const AvatarFallback = React.forwardRef<
  React.ElementRef<typeof AvatarPrimitive.Fallback>,
  React.ComponentPropsWithoutRef<typeof AvatarPrimitive.Fallback>
>(({ className, ...props }, ref) => (
  <AvatarPrimitive.Fallback
    ref={ref}
    className={cn(
      "flex h-full w-full items-center justify-center rounded-full bg-muted",
      className
    )}
    {...props}
  />
))
AvatarFallback.displayName = AvatarPrimitive.Fallback.displayName

export { Avatar, AvatarImage, AvatarFallback }

```

# frontend/src/components/ui/badge.tsx

```tsx
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const badgeVariants = cva(
  "inline-flex items-center rounded-md border px-2.5 py-0.5 text-xs font-semibold transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default:
          "border-transparent bg-primary text-primary-foreground shadow hover:bg-primary/80",
        secondary:
          "border-transparent bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive:
          "border-transparent bg-destructive text-destructive-foreground shadow hover:bg-destructive/80",
        outline: "text-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
  return (
    <div className={cn(badgeVariants({ variant }), className)} {...props} />
  )
}

export { Badge, badgeVariants }

```

# frontend/src/components/ui/button.tsx

```tsx
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow hover:bg-primary/90",
        destructive:
          "bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90",
        outline:
          "border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground",
        secondary:
          "bg-secondary text-secondary-foreground shadow-sm hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2",
        sm: "h-8 rounded-md px-3 text-xs",
        lg: "h-10 rounded-md px-8",
        icon: "h-9 w-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

export interface ButtonProps
  extends React.ButtonHTMLAttributes<HTMLButtonElement>,
    VariantProps<typeof buttonVariants> {
  asChild?: boolean
}

const Button = React.forwardRef<HTMLButtonElement, ButtonProps>(
  ({ className, variant, size, asChild = false, ...props }, ref) => {
    const Comp = asChild ? Slot : "button"
    return (
      <Comp
        className={cn(buttonVariants({ variant, size, className }))}
        ref={ref}
        {...props}
      />
    )
  }
)
Button.displayName = "Button"

export { Button, buttonVariants }

```

# frontend/src/components/ui/custom-pagination.tsx

```tsx
import React from 'react';
import {
  Pagination,
  PaginationContent,
  PaginationEllipsis,
  PaginationItem,
  PaginationLink,
  PaginationNext,
  PaginationPrevious,
} from '@/components/ui/pagination';

interface CustomPaginationProps {
  currentPage: number;
  pageSize: number;
  totalItems: number;
  onPageChange: (page: number) => void;
}

export function CustomPagination({
  currentPage,
  pageSize,
  totalItems,
  onPageChange,
}: CustomPaginationProps) {
  const totalPages = Math.ceil(totalItems / pageSize);
  const maxVisiblePages = 5;

  const getVisiblePages = () => {
    let startPage = Math.max(1, currentPage - Math.floor(maxVisiblePages / 2));
    let endPage = startPage + maxVisiblePages - 1;

    if (endPage > totalPages) {
      endPage = totalPages;
      startPage = Math.max(1, endPage - maxVisiblePages + 1);
    }

    return Array.from(
      { length: endPage - startPage + 1 },
      (_, i) => startPage + i
    );
  };

  const visiblePages = getVisiblePages();

  return (
    <Pagination>
      <PaginationContent>
        <PaginationItem>
          <PaginationPrevious
            href="#"
            onClick={(e) => {
              e.preventDefault();
              if (currentPage > 1) onPageChange(currentPage - 1);
            }}
          />
        </PaginationItem>

        {visiblePages[0] > 1 && (
          <>
            <PaginationItem>
              <PaginationLink
                href="#"
                onClick={(e) => {
                  e.preventDefault();
                  onPageChange(1);
                }}
              >
                1
              </PaginationLink>
            </PaginationItem>
            {visiblePages[0] > 2 && (
              <PaginationItem>
                <PaginationEllipsis />
              </PaginationItem>
            )}
          </>
        )}

        {visiblePages.map((page) => (
          <PaginationItem key={page}>
            <PaginationLink
              href="#"
              isActive={page === currentPage}
              onClick={(e) => {
                e.preventDefault();
                onPageChange(page);
              }}
            >
              {page}
            </PaginationLink>
          </PaginationItem>
        ))}

        {visiblePages[visiblePages.length - 1] < totalPages && (
          <>
            {visiblePages[visiblePages.length - 1] < totalPages - 1 && (
              <PaginationItem>
                <PaginationEllipsis />
              </PaginationItem>
            )}
            <PaginationItem>
              <PaginationLink
                href="#"
                onClick={(e) => {
                  e.preventDefault();
                  onPageChange(totalPages);
                }}
              >
                {totalPages}
              </PaginationLink>
            </PaginationItem>
          </>
        )}

        <PaginationItem>
          <PaginationNext
            href="#"
            onClick={(e) => {
              e.preventDefault();
              if (currentPage < totalPages) onPageChange(currentPage + 1);
            }}
          />
        </PaginationItem>
      </PaginationContent>
    </Pagination>
  );
}

```

# frontend/src/components/ui/dialog.tsx

```tsx
import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"

import { cn } from "@/lib/utils"

const Dialog = DialogPrimitive.Root

const DialogTrigger = DialogPrimitive.Trigger

const DialogPortal = DialogPrimitive.Portal

const DialogClose = DialogPrimitive.Close

const DialogOverlay = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Overlay>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Overlay>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Overlay
    ref={ref}
    className={cn(
      "fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      className
    )}
    {...props}
  />
))
DialogOverlay.displayName = DialogPrimitive.Overlay.displayName

const DialogContent = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Content>
>(({ className, children, ...props }, ref) => (
  <DialogPortal>
    <DialogOverlay />
    <DialogPrimitive.Content
      ref={ref}
      className={cn(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-lg translate-x-[-50%] translate-y-[-50%] gap-4 border bg-background p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg",
        className
      )}
      {...props}
    >
      {children}
    </DialogPrimitive.Content>
  </DialogPortal>
))
DialogContent.displayName = DialogPrimitive.Content.displayName

const DialogHeader = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col space-y-1.5 text-center sm:text-left",
      className
    )}
    {...props}
  />
)
DialogHeader.displayName = "DialogHeader"

const DialogFooter = ({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) => (
  <div
    className={cn(
      "flex flex-col-reverse sm:flex-row sm:justify-end sm:space-x-2",
      className
    )}
    {...props}
  />
)
DialogFooter.displayName = "DialogFooter"

const DialogTitle = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Title>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Title>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Title
    ref={ref}
    className={cn(
      "text-lg font-semibold leading-none tracking-tight",
      className
    )}
    {...props}
  />
))
DialogTitle.displayName = DialogPrimitive.Title.displayName

const DialogDescription = React.forwardRef<
  React.ElementRef<typeof DialogPrimitive.Description>,
  React.ComponentPropsWithoutRef<typeof DialogPrimitive.Description>
>(({ className, ...props }, ref) => (
  <DialogPrimitive.Description
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props}
  />
))
DialogDescription.displayName = DialogPrimitive.Description.displayName

export {
  Dialog,
  DialogPortal,
  DialogOverlay,
  DialogClose,
  DialogTrigger,
  DialogContent,
  DialogHeader,
  DialogFooter,
  DialogTitle,
  DialogDescription,
}

```

# frontend/src/components/ui/input.tsx

```tsx
import * as React from "react";
import { cn } from "@/lib/utils";

export interface InputProps
  extends React.InputHTMLAttributes<HTMLInputElement> {}

const Input = React.forwardRef<HTMLInputElement, InputProps>(
  ({ className, type, ...props }, ref) => {
    return (
      <input
        type={type}
        className={cn(
          "flex h-9 w-full rounded-md border border-input bg-transparent px-3 py-1 text-sm shadow-sm transition-colors file:border-0 file:bg-transparent file:text-sm file:font-medium placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:cursor-not-allowed disabled:opacity-50",
          className
        )}
        ref={ref}
        {...props}
      />
    );
  }
);
Input.displayName = "Input";

export { Input };

```

# frontend/src/components/ui/pagination.tsx

```tsx
import * as React from "react"
import { ChevronLeft, ChevronRight, MoreHorizontal } from "lucide-react"

import { cn } from "@/lib/utils"
import { ButtonProps, buttonVariants } from "@/components/ui/button"

const Pagination = ({ className, ...props }: React.ComponentProps<"nav">) => (
  <nav
    role="navigation"
    aria-label="pagination"
    className={cn("mx-auto flex w-full justify-center", className)}
    {...props}
  />
)
Pagination.displayName = "Pagination"

const PaginationContent = React.forwardRef<
  HTMLUListElement,
  React.ComponentProps<"ul">
>(({ className, ...props }, ref) => (
  <ul
    ref={ref}
    className={cn("flex flex-row items-center gap-1", className)}
    {...props}
  />
))
PaginationContent.displayName = "PaginationContent"

const PaginationItem = React.forwardRef<
  HTMLLIElement,
  React.ComponentProps<"li">
>(({ className, ...props }, ref) => (
  <li ref={ref} className={cn("", className)} {...props} />
))
PaginationItem.displayName = "PaginationItem"

type PaginationLinkProps = {
  isActive?: boolean
} & Pick<ButtonProps, "size"> &
  React.ComponentProps<"a">

const PaginationLink = ({
  className,
  isActive,
  size = "icon",
  ...props
}: PaginationLinkProps) => (
  <a
    aria-current={isActive ? "page" : undefined}
    className={cn(
      buttonVariants({
        variant: isActive ? "outline" : "ghost",
        size,
      }),
      className
    )}
    {...props}
  />
)
PaginationLink.displayName = "PaginationLink"

const PaginationPrevious = ({
  className,
  ...props
}: React.ComponentProps<typeof PaginationLink>) => (
  <PaginationLink
    aria-label="Go to previous page"
    size="default"
    className={cn("gap-1 pl-2.5", className)}
    {...props}
  >
    <ChevronLeft className="h-4 w-4" />
    <span>Previous</span>
  </PaginationLink>
)
PaginationPrevious.displayName = "PaginationPrevious"

const PaginationNext = ({
  className,
  ...props
}: React.ComponentProps<typeof PaginationLink>) => (
  <PaginationLink
    aria-label="Go to next page"
    size="default"
    className={cn("gap-1 pr-2.5", className)}
    {...props}
  >
    <span>Next</span>
    <ChevronRight className="h-4 w-4" />
  </PaginationLink>
)
PaginationNext.displayName = "PaginationNext"

const PaginationEllipsis = ({
  className,
  ...props
}: React.ComponentProps<"span">) => (
  <span
    aria-hidden
    className={cn("flex h-9 w-9 items-center justify-center", className)}
    {...props}
  >
    <MoreHorizontal className="h-4 w-4" />
    <span className="sr-only">More pages</span>
  </span>
)
PaginationEllipsis.displayName = "PaginationEllipsis"

export {
  Pagination,
  PaginationContent,
  PaginationLink,
  PaginationItem,
  PaginationPrevious,
  PaginationNext,
  PaginationEllipsis,
}

```

# frontend/src/components/ui/skeleton.tsx

```tsx
import { cn } from "@/lib/utils"

function Skeleton({
  className,
  ...props
}: React.HTMLAttributes<HTMLDivElement>) {
  return (
    <div
      className={cn("animate-pulse rounded-md bg-primary/10", className)}
      {...props}
    />
  )
}

export { Skeleton }

```

# frontend/src/components/ui/table.tsx

```tsx
import * as React from "react"

import { cn } from "@/lib/utils"

const Table = React.forwardRef<
  HTMLTableElement,
  React.HTMLAttributes<HTMLTableElement>
>(({ className, ...props }, ref) => (
  <div className="relative w-full overflow-auto">
    <table
      ref={ref}
      className={cn("w-full caption-bottom text-sm", className)}
      {...props}
    />
  </div>
))
Table.displayName = "Table"

const TableHeader = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <thead ref={ref} className={cn("[&_tr]:border-b", className)} {...props} />
))
TableHeader.displayName = "TableHeader"

const TableBody = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tbody
    ref={ref}
    className={cn("[&_tr:last-child]:border-0", className)}
    {...props}
  />
))
TableBody.displayName = "TableBody"

const TableFooter = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tfoot
    ref={ref}
    className={cn(
      "border-t bg-muted/50 font-medium [&>tr]:last:border-b-0",
      className
    )}
    {...props}
  />
))
TableFooter.displayName = "TableFooter"

const TableRow = React.forwardRef<
  HTMLTableRowElement,
  React.HTMLAttributes<HTMLTableRowElement>
>(({ className, ...props }, ref) => (
  <tr
    ref={ref}
    className={cn(
      "border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted",
      className
    )}
    {...props}
  />
))
TableRow.displayName = "TableRow"

const TableHead = React.forwardRef<
  HTMLTableCellElement,
  React.ThHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <th
    ref={ref}
    className={cn(
      "h-10 px-2 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
      className
    )}
    {...props}
  />
))
TableHead.displayName = "TableHead"

const TableCell = React.forwardRef<
  HTMLTableCellElement,
  React.TdHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <td
    ref={ref}
    className={cn(
      "p-2 align-middle [&:has([role=checkbox])]:pr-0 [&>[role=checkbox]]:translate-y-[2px]",
      className
    )}
    {...props}
  />
))
TableCell.displayName = "TableCell"

const TableCaption = React.forwardRef<
  HTMLTableCaptionElement,
  React.HTMLAttributes<HTMLTableCaptionElement>
>(({ className, ...props }, ref) => (
  <caption
    ref={ref}
    className={cn("mt-4 text-sm text-muted-foreground", className)}
    {...props}
  />
))
TableCaption.displayName = "TableCaption"

export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
}

```

# frontend/src/components/ui/tabs.tsx

```tsx
import * as React from "react";
import * as TabsPrimitive from "@radix-ui/react-tabs";
import { cn } from "@/lib/utils";

const Tabs = TabsPrimitive.Root;

const TabsList = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.List>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.List>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.List
    ref={ref}
    className={cn(
      "inline-flex h-9 items-center justify-center rounded-lg bg-muted p-1 text-muted-foreground",
      className
    )}
    {...props}
  />
));
TabsList.displayName = TabsPrimitive.List.displayName;

const TabsTrigger = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Trigger>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Trigger>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Trigger
    ref={ref}
    className={cn(
      "inline-flex items-center justify-center whitespace-nowrap rounded-md px-3 py-1 text-sm font-medium ring-offset-background transition-all focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:bg-background data-[state=active]:text-foreground data-[state=active]:shadow",
      className
    )}
    {...props}
  />
));
TabsTrigger.displayName = TabsPrimitive.Trigger.displayName;

const TabsContent = React.forwardRef<
  React.ElementRef<typeof TabsPrimitive.Content>,
  React.ComponentPropsWithoutRef<typeof TabsPrimitive.Content>
>(({ className, ...props }, ref) => (
  <TabsPrimitive.Content
    ref={ref}
    className={cn(
      "mt-2 ring-offset-background focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2",
      className
    )}
    {...props}
  />
));
TabsContent.displayName = TabsPrimitive.Content.displayName;

export { Tabs, TabsList, TabsTrigger, TabsContent };

```

# frontend/src/components/ui/textarea.tsx

```tsx
import * as React from "react"

import { cn } from "@/lib/utils"

export interface TextareaProps
  extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {}

const Textarea = React.forwardRef<HTMLTextAreaElement, TextareaProps>(
  ({ className, ...props }, ref) => {
    return (
      <textarea
        className={cn(
          "flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-sm ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
          className
        )}
        ref={ref}
        {...props}
      />
    )
  }
)
Textarea.displayName = "Textarea"

export { Textarea }

```

# frontend/src/components/WebSocketTest.tsx

```tsx
import { useWebSocket } from '@/hooks/useWebSocket';
import { useEffect, useState } from 'react';

export function WebSocketTest() {
  const { status, isConnected, sendMessage } = useWebSocket();
  const [messageCount, setMessageCount] = useState(0);

  useEffect(() => {
    // Send a test message every 5 seconds
    const interval = setInterval(() => {
      if (isConnected) {
        sendMessage('ad:status', {
          id: messageCount + 1,
          status: 'test',
          timestamp: new Date().toISOString()
        });
        setMessageCount(prev => prev + 1);
      }
    }, 5000);

    return () => clearInterval(interval);
  }, [isConnected, sendMessage, messageCount]);

  return (
    <div className="p-4 bg-white rounded shadow">
      <h2 className="text-xl font-bold mb-4">WebSocket Test</h2>
      
      <div className="space-y-2">
        <div>
          <span className="font-semibold">Connection Status: </span>
          <span className={isConnected ? 'text-green-600' : 'text-red-600'}>
            {isConnected ? 'Connected' : 'Disconnected'}
          </span>
        </div>

        <div>
          <span className="font-semibold">WhatsApp Status: </span>
          <span className={status.isConnected ? 'text-green-600' : 'text-red-600'}>
            {status.isConnected ? 'Connected' : 'Disconnected'}
          </span>
        </div>

        {status.qrCode && (
          <div>
            <span className="font-semibold">QR Code Available</span>
            <div className="mt-2 p-2 bg-gray-100 rounded">
              <pre className="text-xs">{status.qrCode}</pre>
            </div>
          </div>
        )}

        <div>
          <span className="font-semibold">Test Messages Sent: </span>
          <span>{messageCount}</span>
        </div>

        <div className="mt-4">
          <button
            onClick={() => {
              sendMessage('ad:status', {
                id: 'manual-test',
                status: 'manual',
                timestamp: new Date().toISOString()
              });
            }}
            className="px-4 py-2 bg-blue-500 text-white rounded hover:bg-blue-600"
          >
            Send Test Message
          </button>
        </div>
      </div>
    </div>
  );
}

```

# frontend/src/components/WhatsAppQRCode.tsx

```tsx
'use client';

import { useEffect, useState } from 'react';
import { QRCodeSVG } from 'qrcode.react';
import { ArrowPathIcon, PhoneIcon } from '@heroicons/react/24/outline';

interface WhatsAppQRCodeProps {
  qrCode: string;
  onRefresh?: () => void;
}

export function WhatsAppQRCode({ qrCode, onRefresh }: WhatsAppQRCodeProps) {
  const [isValid, setIsValid] = useState(true);
  const [errorMessage, setErrorMessage] = useState<string | null>(null);
  const [qrValue, setQrValue] = useState<string | null>(null);

  // Validate and process QR code on mount and when it changes
  useEffect(() => {
    if (!qrCode) {
      setIsValid(false);
      setErrorMessage('No QR code available');
      setQrValue(null);
      return;
    }

    // Basic validation - QR code should be a non-empty string
    if (typeof qrCode !== 'string' || qrCode.trim().length === 0) {
      setIsValid(false);
      setErrorMessage('Invalid QR code format');
      setQrValue(null);
      return;
    }

    // Check if the QR code is in the expected format
    const qrParts = qrCode.split(',');
    if (qrParts.length !== 5 || !qrParts[0].startsWith('2@')) {
      setIsValid(false);
      setErrorMessage('Invalid WhatsApp QR code format');
      setQrValue(null);
      return;
    }

    setIsValid(true);
    setErrorMessage(null);
    setQrValue(qrCode);
  }, [qrCode]);

  console.log('[WhatsAppQRCode] Rendering:', {
    qrCode: qrCode ? `${qrCode.slice(0, 20)}...` : null,
    length: qrCode?.length,
    isValid,
    errorMessage,
    hasQrValue: Boolean(qrValue)
  });

  if (!isValid) {
    return (
      <div className="bg-white p-6 rounded-lg shadow-lg max-w-sm mx-auto text-center">
        <div className="text-red-500 mb-4">
          <p className="font-medium">Unable to display QR code</p>
          <p className="text-sm mt-1">{errorMessage}</p>
        </div>
        {onRefresh && (
          <button
            onClick={onRefresh}
            className="inline-flex items-center gap-2 text-sm text-indigo-600 hover:text-indigo-500"
          >
            <ArrowPathIcon className="h-4 w-4" />
            Try Again
          </button>
        )}
      </div>
    );
  }

  return (
    <div className="bg-white p-6 rounded-lg shadow-lg max-w-sm mx-auto text-center">
      <div className="mb-4">
        <h3 className="text-lg font-semibold text-gray-900 mb-2">
          Connect WhatsApp
        </h3>
        <p className="text-sm text-gray-600">
          To use WhatsApp Ads, scan this QR code with your phone
        </p>
      </div>

      <div className="bg-white p-4 rounded-lg border-2 border-dashed border-gray-200 mb-4">
        {qrValue ? (
          <QRCodeSVG 
            value={qrValue} 
            size={240}
            level="H"
            includeMargin
            style={{ maxWidth: '100%', height: 'auto' }}
          />
        ) : (
          <div className="flex items-center justify-center w-[240px] h-[240px] bg-gray-50 rounded">
            <p className="text-sm text-gray-500">QR code not available</p>
          </div>
        )}
      </div>

      <div className="space-y-4">
        <div className="flex items-center justify-center gap-2 text-sm text-gray-600">
          <PhoneIcon className="h-5 w-5" />
          <span>Open WhatsApp on your phone</span>
        </div>

        <ol className="text-sm text-gray-600 text-left space-y-2">
          <li>1. Tap Menu or Settings</li>
          <li>2. Select WhatsApp Web</li>
          <li>3. Point your phone camera at this screen</li>
        </ol>

        {onRefresh && (
          <button
            onClick={onRefresh}
            className="inline-flex items-center gap-2 text-sm text-indigo-600 hover:text-indigo-500"
          >
            <ArrowPathIcon className="h-4 w-4" />
            Refresh QR Code
          </button>
        )}
      </div>
    </div>
  );
}

```

# frontend/src/hooks/useWebSocket.ts

```ts
import { useEffect, useState, useCallback } from 'react';
import { WebSocketService, WSEventType } from '@/services/WebSocketService';

interface WhatsAppStatus {
  isConnected: boolean;
  qrCode: string | null;
  lastError?: string;
}

interface UseWebSocketReturn {
  status: WhatsAppStatus;
  isConnected: boolean;
  sendMessage: (type: WSEventType, data: any) => void;
}

const WS_URL = process.env.NEXT_PUBLIC_WS_URL || 'ws://localhost:8000';

export function useWebSocket(): UseWebSocketReturn {
  const [ws, setWs] = useState<WebSocketService | null>(null);
  const [status, setStatus] = useState<WhatsAppStatus>({
    isConnected: false,
    qrCode: null,
  });

  // Log WebSocket events in development
  const logEvent = useCallback((event: string, data?: any) => {
    if (process.env.NODE_ENV === 'development') {
      console.log(`[WebSocket] ${event}:`, data || '');
    }
  }, []);

  useEffect(() => {
    const wsService = new WebSocketService(WS_URL);

    wsService.on('connected', () => {
      logEvent('Connected');
      setStatus((prev) => ({
        ...prev,
        isConnected: true,
        lastError: undefined
      }));
    });

    wsService.on('disconnected', () => {
      logEvent('Disconnected');
      setStatus((prev) => ({
        ...prev,
        isConnected: false,
        // Keep QR code when disconnected to avoid flashing
        // qrCode: null
      }));
    });

    wsService.on('error', (error) => {
      logEvent('Error', error);
      setStatus((prev) => ({
        ...prev,
        lastError: error.message
      }));
    });

    wsService.on('whatsapp:qr', (data) => {
      if (!data.qr) {
        logEvent('Invalid QR Code Received', data);
        return;
      }

      logEvent('QR Code Received', {
        qrLength: data.qr.length,
        qrStart: data.qr.slice(0, 20)
      });

      setStatus((prev) => {
        // Only update if QR code is different
        if (prev.qrCode === data.qr) {
          return prev;
        }

        const newStatus = {
          ...prev,
          qrCode: data.qr,
          isConnected: false // Reset connected state when new QR code arrives
        };

        console.log('[useWebSocket] Updated status:', {
          ...newStatus,
          qrCode: newStatus.qrCode ? `${newStatus.qrCode.slice(0, 20)}...` : null
        });

        return newStatus;
      });
    });

    wsService.on('whatsapp:ready', () => {
      logEvent('WhatsApp Ready');
      setStatus((prev) => ({
        ...prev,
        isConnected: true,
        qrCode: null,
        lastError: undefined
      }));
    });

    wsService.on('whatsapp:authenticated', () => {
      logEvent('WhatsApp Authenticated');
      setStatus((prev) => ({
        ...prev,
        isConnected: true,
        qrCode: null,
        lastError: undefined
      }));
    });

    wsService.on('whatsapp:disconnected', () => {
      logEvent('WhatsApp Disconnected');
      setStatus((prev) => ({
        ...prev,
        isConnected: false,
        // Don't clear QR code on disconnect to avoid flashing
        // qrCode: null
      }));
    });

    // Handle ad-related events
    wsService.on('ad:status', (data) => {
      logEvent('Ad Status Update', data);
    });

    wsService.on('ad:progress', (data) => {
      logEvent('Ad Progress Update', data);
    });

    setWs(wsService);

    return () => {
      wsService.disconnect();
    };
  }, [logEvent]);

  const sendMessage = useCallback((type: WSEventType, data: any) => {
    if (ws?.isConnected()) {
      logEvent('Sending Message', { type, data });
      ws.send(type, data);
    } else {
      console.warn('[WebSocket] Cannot send message: not connected');
    }
  }, [ws, logEvent]);

  return {
    status,
    isConnected: ws?.isConnected() || false,
    sendMessage,
  };
}

```

# frontend/src/lib/utils.ts

```ts
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}

```

# frontend/src/services/api.ts

```ts
import axios from 'axios';
import type { 
  User, 
  ContactGroup, 
  PhoneBookEntry, 
  MessageTemplate, 
  AdJob, 
  ModerationLog 
} from '@/types';

const API_URL = process.env.NEXT_PUBLIC_API_URL || 'http://localhost:8000';

const api = axios.create({
  baseURL: API_URL,
  headers: {
    'Content-Type': 'application/json',
  },
});

export const whatsappApi = {
  getStatus: () => api.get('/whatsapp/status'),
  getContacts: () => api.get<ContactGroup[]>('/whatsapp/contacts'),
  getGroups: () => api.get<ContactGroup[]>('/whatsapp/groups'),
};

export const phoneBookApi = {
  getEntries: () => api.get<PhoneBookEntry[]>('/phonebook'),
  addEntry: (entry: Omit<PhoneBookEntry, 'id'>) => api.post<PhoneBookEntry>('/phonebook', entry),
  updateEntry: (id: number, entry: Partial<PhoneBookEntry>) => 
    api.put<PhoneBookEntry>(`/phonebook/${id}`, entry),
  deleteEntry: (id: number) => api.delete(`/phonebook/${id}`),
};

export const templateApi = {
  getTemplates: () => api.get<MessageTemplate[]>('/api/templates/list'),
  createTemplate: (template: Omit<MessageTemplate, 'id' | 'createdAt' | 'updatedAt'>) => 
    api.post<MessageTemplate>('/api/templates/create', template),
  updateTemplate: (id: number, template: Partial<MessageTemplate>) => 
    api.put<MessageTemplate>(`/api/templates/update`, {id, template}),
  deleteTemplate: (id: number) => api.delete(`/api/templates/delete?id=${id}`),
};

export const adJobApi = {
  getJob: (id: number) => api.get<AdJob>(`/jobs/${id}`),
  getJobs: () => api.get<AdJob[]>('/jobs'),
  createJob: (job: Omit<AdJob, 'id' | 'status' | 'messagesSent' | 'messagesDelivered' | 'createdAt' | 'updatedAt'>) => 
    api.post<AdJob>('/jobs', job),
  updateJobStatus: (id: number, status: AdJob['status']) => 
    api.put<AdJob>(`/jobs/${id}/status`, { status }),
  getJobLogs: (jobId: number) => api.get<ModerationLog[]>(`/jobs/${jobId}/logs`),
  startJob: (id: number) => api.post<AdJob>(`/jobs/${id}/start`),
  stopJob: (id: number) => api.post<AdJob>(`/jobs/${id}/stop`),
  updateJobSchedule: (id: number, schedule: any) => api.put<AdJob>(`/jobs/${id}/schedule`, { schedule }),
};

export const moderationApi = {
  getModerationQueue: () => api.get<AdJob[]>('/moderation/queue'),
  moderateJob: (jobId: number, action: ModerationLog['action'], notes?: string) => 
    api.post<ModerationLog>(`/moderation/${jobId}`, { action, notes }),
};

```

# frontend/src/services/websocket.ts

```ts
import { create } from 'zustand';
import type { WhatsAppStatus } from '@/types';
import { WSMessage } from '@/shared/types/websocket';

interface WebSocketStore {
  socket: WebSocket | null;
  status: WhatsAppStatus;
  connect: () => void;
  disconnect: () => void;
  setStatus: (status: Partial<WhatsAppStatus>) => void;
}

const WS_URL = process.env.NEXT_PUBLIC_WS_URL || 'ws://localhost:8000';

export const useWebSocket = create<WebSocketStore>((set, get) => ({
  socket: null,
  status: {
    isConnected: false,
  },
  connect: () => {
    const socket = new WebSocket(WS_URL);
    
    socket.onopen = () => {
      set({ socket });
    };

    socket.onmessage = (event) => {
      try {
        const message: WSMessage = JSON.parse(event.data);
        
        switch (message.type) {
          case 'whatsapp:qr':
            set(state => ({
              status: {
                ...state.status,
                qrCode: message.data.qr,
              },
            }));
            break;
          
          case 'whatsapp:ready':
            set(state => ({
              status: {
                ...state.status,
                isConnected: true,
                qrCode: undefined,
                lastConnection: message.data.timestamp,
              },
            }));
            break;
          
          case 'whatsapp:authenticated':
            set(state => ({
              status: {
                ...state.status,
                isConnected: true,
                qrCode: undefined,
              },
            }));
            break;
          
          case 'whatsapp:disconnected':
            set(state => ({
              status: {
                ...state.status,
                isConnected: false,
                lastConnection: message.data.timestamp,
              },
            }));
            break;
        }
      } catch (error) {
        console.error('Failed to parse WebSocket message:', error);
      }
    };

    socket.onclose = () => {
      set({ 
        socket: null,
        status: {
          isConnected: false,
          qrCode: undefined,
        },
      });
      // Attempt to reconnect after 5 seconds
      setTimeout(() => get().connect(), 5000);
    };

    socket.onerror = (error) => {
      console.error('WebSocket error:', error);
      socket.close();
    };
  },
  
  disconnect: () => {
    const { socket } = get();
    if (socket) {
      socket.close();
      set({ socket: null });
    }
  },

  setStatus: (newStatus) => {
    set(state => ({
      status: {
        ...state.status,
        ...newStatus,
      },
    }));
  },
}));

```

# frontend/src/services/WebSocketService.ts

```ts
import { WSEventType, WSMessage } from '@/shared/types/websocket';
import { EventEmitter } from 'events';

const debug = (message: string, ...args: any[]) => {
  if (process.env.NODE_ENV === 'development') {
    console.log(`[WebSocket] ${message}`, ...args);
  }
};

const debugError = (message: string, ...args: any[]) => {
  if (process.env.NODE_ENV === 'development') {
    console.error(`[WebSocket Error] ${message}`, ...args);
  }
};

export class WebSocketService extends EventEmitter {
  private ws: WebSocket | null = null;
  private reconnectAttempts = 0;
  private maxReconnectAttempts = 5;
  private reconnectTimeout = 1000; // Start with 1 second
  private connectionStartTime: number = 0;
  private reconnectTimer: NodeJS.Timeout | null = null;
  private messageQueue: { type: WSEventType; data: any }[] = [];

  constructor(private url: string) {
    super();
    debug('Initializing WebSocket service', { url });
    this.connect();
  }

  private connect() {
    try {
      debug('Attempting to connect...');
      this.connectionStartTime = Date.now();
      this.ws = new WebSocket(this.url);
      this.setupEventListeners();
    } catch (error) {
      debugError('Failed to connect:', error);
      this.handleReconnect();
    }
  }

  private setupEventListeners() {
    if (!this.ws) {
      debugError('No WebSocket instance available');
      return;
    }

    this.ws.onopen = () => {
      const connectionTime = Date.now() - this.connectionStartTime;
      debug(`Connected in ${connectionTime}ms`, {
        url: this.url,
        readyState: this.ws?.readyState,
        queuedMessages: this.messageQueue.length
      });

      this.reconnectAttempts = 0;
      this.reconnectTimeout = 1000;
      this.emit('connected');

      // Process any queued messages
      const queuedMessages = [...this.messageQueue]; // Create a copy to avoid mutation during iteration
      this.messageQueue = [];

      queuedMessages.forEach(message => {
        debug('Processing queued message:', {
          type: message.type,
          data: message.data
        });
        this.send(message.type, message.data);
      });
    };

    this.ws.onclose = (event) => {
      debug('Disconnected', {
        code: event.code,
        reason: event.reason,
        wasClean: event.wasClean
      });
      this.emit('disconnected');
      this.handleReconnect();
    };

    this.ws.onerror = (error) => {
      debugError('Connection error:', error);
      this.emit('error', error);
    };

    this.ws.onmessage = (event) => {
      try {
        const message: WSMessage = JSON.parse(event.data);
        debug('Received message', {
          type: message.type,
          data: message.type === 'whatsapp:qr' 
            ? { qrLength: message.data.qr?.length, qrStart: message.data.qr?.slice(0, 20) }
            : message.data,
          size: event.data.length,
          readyState: this.ws?.readyState
        });

        // Validate message format before emitting
        if (!message.type) {
          throw new Error('Message type is missing');
        }

        this.emit(message.type, message.data);
      } catch (error) {
        debugError('Failed to parse message:', error, '\nRaw message:', event.data);
      }
    };
  }

  private handleReconnect() {
    if (this.reconnectAttempts >= this.maxReconnectAttempts) {
      debugError('Max reconnection attempts reached');
      this.emit('max_reconnect_attempts');
      return;
    }

    const nextAttempt = this.reconnectTimeout * Math.pow(2, this.reconnectAttempts);
    debug('Scheduling reconnect', {
      attempt: this.reconnectAttempts + 1,
      delay: nextAttempt,
      maxAttempts: this.maxReconnectAttempts
    });

    // Clear any existing reconnect timeout
    if (this.reconnectTimer) {
      clearTimeout(this.reconnectTimer);
    }

    this.reconnectTimer = setTimeout(() => {
      this.reconnectAttempts++;
      this.reconnectTimeout *= 2; // Exponential backoff
      this.connect();
    }, nextAttempt);
  }

  public send(type: WSEventType, data: any) {
    if (this.ws?.readyState === WebSocket.OPEN) {
      try {
        const message = JSON.stringify({ type, data });
        debug('Sending message', {
          type,
          data: type === 'whatsapp:qr' 
            ? { qrLength: data.qr?.length, qrStart: data.qr?.slice(0, 20) }
            : data,
          size: message.length,
          readyState: this.ws?.readyState
        });
        this.ws.send(message);
      } catch (error) {
        debugError('Failed to send message:', error, { type, data });
        // Queue the message for retry
        this.messageQueue.push({ type, data });
      }
    } else {
      debug('Queueing message - not connected', {
        readyState: this.ws?.readyState,
        type,
        data: type === 'whatsapp:qr' 
          ? { qrLength: data.qr?.length, qrStart: data.qr?.slice(0, 20) }
          : data,
        queueLength: this.messageQueue.length + 1
      });
      // Queue the message to be sent when connection is established
      this.messageQueue.push({ type, data });
      // Attempt to reconnect if not already trying
      if (!this.reconnectTimer && (!this.ws || this.ws.readyState === WebSocket.CLOSED)) {
        this.connect();
      }
    }
  }

  public isConnected(): boolean {
    const connected = this.ws?.readyState === WebSocket.OPEN;
    debug('Connection status check', {
      connected,
      readyState: this.ws?.readyState
    });
    return connected;
  }

  public disconnect() {
    if (this.reconnectTimer) {
      clearTimeout(this.reconnectTimer);
      this.reconnectTimer = null;
    }

    if (this.ws) {
      debug('Disconnecting...');
      this.ws.close();
      this.ws = null;
    } else {
      debug('Already disconnected');
    }

    // Clear message queue
    this.messageQueue = [];
  }
}

```

# frontend/src/shared

This is a binary file of the type: Binary

# frontend/src/types/index.ts

```ts
export interface User {
  id: number;
  name: string;
  phone: string;
}

export interface ContactGroup {
  id: number;
  name: string;
  phone?: string;
  groupId?: string;
  type: 'contact' | 'group';
  isActive: boolean;
}

export interface PhoneBookEntry {
  id: number;
  name: string;
  phone: string;
  groupName?: string;
}

export interface MessageTemplate {
  id: number;
  title: string;
  messages: string[];
  createdAt: string;
  updatedAt: string;
}

export interface AdJob {
  id: number;
  userId: number;
  templateId: number;
  status: 'pending' | 'approved' | 'rejected' | 'running' | 'completed' | 'failed' | 'stopped';
  audience: string;
  messagesSent: number;
  messagesDelivered: number;
  createdAt: string;
  updatedAt: string;
}

export interface ModerationLog {
  id: number;
  jobId: number;
  moderator: string;
  action: 'approved' | 'rejected' | 'modified';
  notes?: string;
  createdAt: string;
}

export interface WhatsAppStatus {
  isConnected: boolean;
  qrCode?: string;
  lastConnection?: string;
}

```

# frontend/tailwind.config.js

```js
/** @type {import('tailwindcss').Config} */
module.exports = {
    darkMode: ['class'],
    content: [
    './src/pages/**/*.{js,ts,jsx,tsx,mdx}',
    './src/components/**/*.{js,ts,jsx,tsx,mdx}',
    './src/app/**/*.{js,ts,jsx,tsx,mdx}',
  ],
  theme: {
  	extend: {
  		colors: {
  			background: 'hsl(var(--background))',
  			foreground: 'hsl(var(--foreground))',
  			card: {
  				DEFAULT: 'hsl(var(--card))',
  				foreground: 'hsl(var(--card-foreground))'
  			},
  			popover: {
  				DEFAULT: 'hsl(var(--popover))',
  				foreground: 'hsl(var(--popover-foreground))'
  			},
  			primary: {
  				DEFAULT: 'hsl(var(--primary))',
  				foreground: 'hsl(var(--primary-foreground))'
  			},
  			secondary: {
  				DEFAULT: 'hsl(var(--secondary))',
  				foreground: 'hsl(var(--secondary-foreground))'
  			},
  			muted: {
  				DEFAULT: 'hsl(var(--muted))',
  				foreground: 'hsl(var(--muted-foreground))'
  			},
  			accent: {
  				DEFAULT: 'hsl(var(--accent))',
  				foreground: 'hsl(var(--accent-foreground))'
  			},
  			destructive: {
  				DEFAULT: 'hsl(var(--destructive))',
  				foreground: 'hsl(var(--destructive-foreground))'
  			},
  			border: 'hsl(var(--border))',
  			input: 'hsl(var(--input))',
  			ring: 'hsl(var(--ring))',
  			chart: {
  				'1': 'hsl(var(--chart-1))',
  				'2': 'hsl(var(--chart-2))',
  				'3': 'hsl(var(--chart-3))',
  				'4': 'hsl(var(--chart-4))',
  				'5': 'hsl(var(--chart-5))'
  			}
  		},
  		borderRadius: {
  			lg: 'var(--radius)',
  			md: 'calc(var(--radius) - 2px)',
  			sm: 'calc(var(--radius) - 4px)'
  		}
  	}
  },
  plugins: [require("tailwindcss-animate")],
}

```

# frontend/tsconfig.json

```json
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    "baseUrl": ".",
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"],
      "@shared/*": ["./src/shared/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts"],
  "exclude": ["node_modules"]
}

```

# README.md

```md
# WhatsApp Ads Software

A powerful WhatsApp advertising platform that enables sending ads to contacts, groups, and non-contacts via WhatsApp. Features include a moderation panel, real-time updates, and message template management.

## Technology Stack

- **Backend**: Express.js with express-zod-api
- **Frontend**: Next.js (CSR mode, TypeScript)
- **Database**: SQLite
- **WebSocket**: Real-time updates
- **WhatsApp Integration**: whatsapp-web.js

## Features

- Send ads to WhatsApp contacts, groups, and non-contacts
- Real-time updates via WebSocket
- Moderation panel for ad campaign approval
- Message template management
- Audience management (contacts, groups, phone book)
- Live status tracking for ad campaigns

## Project Structure

\`\`\`
whatsapp-ads/
├── backend/
│   ├── src/
│   │   ├── config/
│   │   ├── entities/
│   │   ├── routes/
│   │   ├── services/
│   │   ├── websocket/
│   │   └── index.ts
│   ├── package.json
│   └── tsconfig.json
└── frontend/
    └── (Next.js structure - coming soon)
\`\`\`

## Getting Started

### Prerequisites

- Node.js (v16 or higher)
- npm or yarn
- SQLite

### Backend Setup

1. Navigate to the backend directory:
   \`\`\`bash
   cd backend
   \`\`\`

2. Install dependencies:
   \`\`\`bash
   npm install
   \`\`\`

3. Create a `.env` file in the backend directory:
   \`\`\`env
   PORT=8000
   NODE_ENV=development
   FRONTEND_URL=http://localhost:3000
   \`\`\`

4. Start the development server:
   \`\`\`bash
   npm run dev
   \`\`\`

### Frontend Setup

Coming soon...

## Database Schema

The application uses SQLite with the following core tables:

- Users
- Contacts & Groups
- Phone Book
- Message Templates
- Ad Jobs
- Moderation Logs

## WebSocket Events

The application uses WebSocket for real-time updates with the following event types:

- `whatsapp:qr` - QR code for WhatsApp Web authentication
- `whatsapp:ready` - WhatsApp client is ready
- `whatsapp:authenticated` - Successfully authenticated
- `whatsapp:disconnected` - WhatsApp client disconnected
- `ad:status` - Ad job status updates
- `ad:progress` - Ad sending progress updates

## Security Considerations

- WhatsApp sessions are securely stored using LocalAuth
- SQLite database is protected within the application directory
- Rate limiting is implemented to prevent WhatsApp blocking
- WebSocket connections are authenticated

## Contributing

Please read [CONTRIBUTING.md](CONTRIBUTING.md) for details on our code of conduct and the process for submitting pull requests.

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

```

# shared/types/contacts.ts

```ts
export interface Contact {
  id: string;
  name: string;
  phoneNumber: string;
  isMyContact: boolean;
  profilePicUrl?: string;
  lastSeen?: Date;
  status?: string;
}

export interface Group {
  id: string;
  name: string;
  description?: string;
  participants: Contact[];
  isAdmin: boolean;
  profilePicUrl?: string;
  createdAt: Date;
}

export interface ContactsResponse {
  contacts: Contact[];
  total: number;
  page: number;
  pageSize: number;
}

export interface GroupsResponse {
  groups: Group[];
  total: number;
  page: number;
  pageSize: number;
}

export interface ContactFilter {
  search?: string;
  isMyContact?: boolean;
  page?: number;
  pageSize?: number;
}

export interface GroupFilter {
  search?: string;
  isAdmin?: boolean;
  page?: number;
  pageSize?: number;
}

```

# shared/types/websocket.ts

```ts
export type WSEventType =
  | 'connection:established'
  | 'whatsapp:qr'
  | 'whatsapp:ready'
  | 'whatsapp:authenticated'
  | 'whatsapp:disconnected'
  | 'whatsapp:error'
  | 'whatsapp:status'
  | 'ad:progress'
  | 'ad:complete'
  | 'ad:error'
  | 'ad:status';

export interface WSMessage {
  type: WSEventType;
  data: any;
}

```

